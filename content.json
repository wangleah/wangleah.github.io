{"meta":{"title":"wangleah","subtitle":"不要因为别人的光芒，而忘了自己想走的路!","description":null,"author":"wangleah","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"mongodb安装、配置及操作命令","slug":"前端工具/mongodb安装及相关配置","date":"2017-03-09T16:00:00.000Z","updated":"2017-03-12T12:43:05.664Z","comments":true,"path":"2017/03/10/前端工具/mongodb安装及相关配置/","link":"","permalink":"http://yoursite.com/2017/03/10/前端工具/mongodb安装及相关配置/","excerpt":"为了更好的学习 MongoDB 数据库，大家可以参考菜鸟教程上的 MongoDB 数据库教程文档，链接地址：http://www.runoob.com/mongodb/mongodb-tutorial.html mongodb数据库官网：https://www.mongodb.com/ 第一步 安装步骤1.先进入网址，点击”download” （网址：https://www.mongodb.com/）","text":"为了更好的学习 MongoDB 数据库，大家可以参考菜鸟教程上的 MongoDB 数据库教程文档，链接地址：http://www.runoob.com/mongodb/mongodb-tutorial.html mongodb数据库官网：https://www.mongodb.com/ 第一步 安装步骤1.先进入网址，点击”download” （网址：https://www.mongodb.com/） 2.点击进行下载，下载zip或者version里面的(安装在C盘或者D盘，最好是安装路径是默认的) 3.检验是不是安装成功 1在cmd终端中输入： mongo --version 或是 mongod --version ,能看到版本好,说明安装成功 第二步 MongoDB配置启动服务器1、创建数据目录 将数据目录放在根目录下(如：c:\\或者D:\\等)，数据目录的命名随意，最好叫 data; 在data文件中建立文件夹 db和log 然后启动执行mongod.exe --dbpath c:\\data 如果启动成功就ok了 2、配置全局启动mongodb（开机直接启动） 首先在data/log文件夹下建立mongodb.log文件 然后打开cmd终端输入 1mongod.exe --bind_ip 127.0.0.1 --logpath &quot;C:/data/log/mongodb.log&quot; --logappend --dbpath &quot;c:/datas&quot; --port 27017 --serviceName &quot;MongoDBServer&quot; --serviceDisplayName &quot;MongoDBServerDisplayName&quot; --install 然后重新打开cmd终端 输入services.msc 可以看到服务界面，启动服务即可 然后这样电脑就自动开启了mongod服务 3、启动连接mongodb服务器 在终端输入 mongo 或者 mongo --host 127.0.0.1 --port 27017 1234567891011如果看到类似于如下的字样说明连接成功： MongoDB shell version v3.4.2 connecting to: mongodb://127.0.0.1:27017 MongoDB server version: 3.4.2 Server has startup warnings: 2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten] 2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database. 2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted. 2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten] &gt; 基本操作命令也可以使用图形化界面robomongo1234可以参考: http://www.yiibai.com/mongodb/mongodb_create_collection.html http://www.runoob.com/mongodb/mongodb-tutorial.html show dbs 查看当前服务实例上所有的数据库 use 数据库名称 如果数据库不存在，则创建数据库，否则切换到指定数据库。 db.dropDatabase() 删除数据库,注意,要在切换的数据库中删除 db 查看当前所处的数据库 show collections 查看当前数据库中所有的集合 db.createCollection(&quot;集合名称&quot;) 创建集合 db.集合名称.drop() 删除集合 db.集合名称.insert({数据文档}) 插入的每一条文档会自动帮我们生成一个_id字段,它是mongodb自动维护的,不需要我们关心 db.集合名称.find() 查询指定集合中所有的数据 可以通过 db.集合名称.find().pretty() 美化输出格式 默认是查询所有，可以通过：db.集合名称.find({查询条件}) 按条件查询集合中的数据 模糊查询的条件 {要查询的字段:{$regex: ‘关键字’}} db.集合名称.update({更新条件}, {要更新的字段}) 更新指定集合数据,注意点,要更新的字段一定要这样写 {$set:{字段的名称:字段的值}}, db.集合名称.remove({删除条件}) 删除指定集合中的数据 exit 退出当前操作 cls 清屏 注意点:更新和删除时一般都需要带条件,除非是全部更新与全部删除,不过全部更新与全部删除这样很危险,实际操作过程中很少","categories":[],"tags":[]},{"title":"原生JS在IE中的兼容性","slug":"javascript/原生JS在IE中的兼容性","date":"2016-09-14T16:00:00.000Z","updated":"2017-03-29T06:58:08.332Z","comments":true,"path":"2016/09/15/javascript/原生JS在IE中的兼容性/","link":"","permalink":"http://yoursite.com/2016/09/15/javascript/原生JS在IE中的兼容性/","excerpt":"","text":"获取某个元素(标签)的文本内容1234567891011121314/** * 获取某个元素(标签)的文本内容 * @param element -----&gt;文本的元素(标签) * @returns &#123;*&#125;----&gt;返回值是文本的内容 */function getInnerText(element) &#123; if (typeof(element.textContent) == \"undefined\") &#123; //IE8 return element.innerText = txt; &#125; else &#123; //谷歌或者火狐 return element.textContent = txt; &#125;&#125; 为元素添加多个事件1234567891011121314151617/** * 为元素添加多个事件---兼容代码 谷歌 火狐 IE8都支持 * 任意的元素,任意的事件,事件对应事件处理函数 * @param element----元素 * @param type---事件类型 * @param fn---事件处理函数 *//*此代码这是判断浏览器是否兼容，而不是用了哪种方法*/function addEventListener(element, type, fn) &#123; if (element.addEventListener) &#123; element.addEventListener(type, fn, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + type, fn); &#125; else &#123; element[\"on\" + type] = fn; &#125;&#125; 移除事件1234567891011121314151617/** * 移除事件---------兼容代码 谷歌 火狐 IE8都支持 * 为任意的元素移除任意的事件,事件对应着事件处理函数 * @param element----元素 * @param type---事件类型 * @param fn----事件处理函数 *//*此代码这是判断浏览器是否兼容，而不是用了哪种方法*/function removeListener(element, type, fn) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, fn, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(\"on\" + type, fn); &#125; else &#123; element[\"on\" + type] = null; &#125;&#125; 阻止冒泡123456789101112/** * 阻止事件冒泡 * @param e */function cancelBubble(e) &#123; e = e || window.event; if (e.stopPropagation) &#123; e.stopPropagation(); &#125; else &#123; e.cancelBubble = true; &#125;&#125; 获取任意元素中的任务属性123456789/** * 获取任意元素中的任务属性 * @param element--&gt;获取的元素 * @param attr----&gt;属性 * @returns &#123;*&#125;---返回值是一个String（字符串） */function getStyle(element, attr) &#123; return element.currentStyle ? element.currentStyle[attr] : window.getComputedStyle(element, null)[attr] || 0;&#125;","categories":[],"tags":[]},{"title":"获取当前元素的所有兄弟元素","slug":"javascript/获取当前元素的所有兄弟元素","date":"2016-08-11T16:00:00.000Z","updated":"2017-03-29T07:00:13.926Z","comments":true,"path":"2016/08/12/javascript/获取当前元素的所有兄弟元素/","link":"","permalink":"http://yoursite.com/2016/08/12/javascript/获取当前元素的所有兄弟元素/","excerpt":"","text":"12345678910111213141516171819202122232425/** * 当前元素的所有兄弟元素 * @param element * @returns &#123;Array&#125; */function getSiblings(element) &#123; var elements = []; //保存当前元素的前面所有元素和后面所有元素 //获取前面的兄弟节点 var ele = element.previousSibling; while (ele) &#123; if (ele.nodeType === 1) &#123; elements.push(ele); &#125; ele = ele.previousSibling; &#125; //获取后面的节点 ele = element.nextSibling; while (ele) &#123; if (ele.nodeType === 1) &#123; elements.push(ele); &#125; ele = ele.nextSibling; &#125; return elements;&#125;","categories":[],"tags":[]},{"title":"自动化构建工具Gulp初体验","slug":"前端工具/自动化构建工具Gulp初体验","date":"2016-08-11T16:00:00.000Z","updated":"2017-03-12T12:41:32.381Z","comments":true,"path":"2016/08/12/前端工具/自动化构建工具Gulp初体验/","link":"","permalink":"http://yoursite.com/2016/08/12/前端工具/自动化构建工具Gulp初体验/","excerpt":"自动化构建工具 对于前端开发来说，自动化构建工具非常重要。他能够帮助我们自动完成许多任务，能够极大的提高我们的工作效率。当然，流行的工具比较多，比如grunt，gulp，webpack等，了解不多的同学可能就开始迷茫了，到底应该学习哪一种？其实实际情况上，除了grunt与gulp是存在替换关系，gulp与其他大多数工具都是可以通过插件相互渗透的，比如webpack，在gulp中有gulp-webpack插件能够完成webpack的工作，比如gulp-bower插件能够完成bower的功能。而gulp比grunt效率更高，更简便的IO操作，更少的API，因此我们只需要好好掌握gulp，就足够了，不需要给自己徒增烦恼。","text":"自动化构建工具 对于前端开发来说，自动化构建工具非常重要。他能够帮助我们自动完成许多任务，能够极大的提高我们的工作效率。当然，流行的工具比较多，比如grunt，gulp，webpack等，了解不多的同学可能就开始迷茫了，到底应该学习哪一种？其实实际情况上，除了grunt与gulp是存在替换关系，gulp与其他大多数工具都是可以通过插件相互渗透的，比如webpack，在gulp中有gulp-webpack插件能够完成webpack的工作，比如gulp-bower插件能够完成bower的功能。而gulp比grunt效率更高，更简便的IO操作，更少的API，因此我们只需要好好掌握gulp，就足够了，不需要给自己徒增烦恼。 学前准备 安装nodejs与npm 在nodejs官网找到对应的版本安装即可，新的nodejs已经集成了npm，在命令行中输入一下指令检测nodejs与npm是否已经安装成功，如果你是在window下使用命令行，建议使用git的命令行工具 12345// 输出node版本&gt; node -v// 输出npm版本&gt; npm -v npm是node的包管理工具，用于管理node的相关插件，使用的几个常用的相关指令如下 12345678// 安装插件&gt; [sudo] npm install &lt;name&gt; [-g] [--save-dev]// 卸载插件&gt; [sudo] npm uninstall &lt;name&gt; [-g] [--save-dev]// 更新插件&gt; [sudo] npm update &lt;name&gt; [-g] [--save-dev] 上面的语法中，中括号[]表示可选参数，尖括号&lt;&gt;表示必填参数，他们分别表示的含义如下 [sudo]: 在类unix操作系统下表示允许使用过通过安全的方式使用特殊权限执行后面的指令，比如在mac os x环境下会因为权限问题指令被拒绝就需要使用到它。 : 插件名字，如果是安装gulp-sass，那么指令如下 1&gt; npm install gulp-sass 安装gulp 在安装之前，请确保已经安装了nodejs与npm 12345// 安装gulp&gt; npm install -g gulp// 通过输出版本号检测是否已经安装成功&gt; gulp -v 于是到这里，一切就准备就绪了，是时候来感受一下gulp的魅力了。 为了大家更好的学习gulp，我在我的github上新建了一个项目 learn-gulp，我会把每一步每一个知识点都作为一次提交push到项目中，这样大家就可以通过查看历史版本，循序渐进的学习gulp的配置了。欢迎大家的fork与star。点击文末的阅读原文或者通过下面的项目地址访问 https://github.com/yangbo5207/learn-gulp 我们先通过一个非常简单的例子，了解一下gulp如何将sass文件编译成css的。在动手尝试之前，我们有2个文件需要重点了解一下 package.json package.json作为gulp的配置文件，能够非常方便的管理nodejs的插件，因为一个项目所要依赖的插件很多，因此不可能将所有的插件都放在git中来管理，我们只需要在项目中保存有一个package.json的配置文件，那么就可以通过下面的指令将该配置文件中的所有依赖包下载下来。 1&gt; npm install 在后续的gulp进阶文章中，我会详细的给大家罗列package.json中所有字段的详细功能。另外，由于这个配置文件中仅仅只是一个json，因此我们可以保存我们自己需要的字段，并且通过node读取使用。 gulpfile.js gulpfile.js是gulp项目中的配置文件，通过这个普通的js文件，我们可以定义gulp的行为，所有的gulp任务都将在这个js文件中来配置。如何编写这个js文件将是我们学会使用gulp的关键。 那么，所有的准备工作与基本的概念我们都有一个了解之后呢，我们就可以通过一个简单的例子来感受一下gulp带给我们的便利了。 实例 通过插件gulp-sass，我们可以将sass文件编译为css文件，sass是css的预编译语言，属于能够10分钟掌握的简单语言，但是它却足够强大，它突破css的局限性，让css也能够玩出花来，值得大家去学习掌握。在实际开发中，为了提高开发效率，我们往往都不会直接使用css，而是通过编写sass或者less，然后编译为css。 任意新建一个文件夹，该文件夹将被当做是我们目前的项目目录。在该目录中安装gulp-sass插件 1&gt; npm install gulp-sass 安装完成之后，我们可以看到目录中生成了一个叫做node-modules的文件夹，gulp-sass插件就被安装在node-modules中。 在该目录下新建一个叫做gulpfile.js的文件，并输入以下代码 1234567891011// gulpfile.js&apos;use strict&apos;;var gulp = require(&apos;gulp&apos;);var sass = require(&apos;gulp-sass&apos;);gulp.task(&apos;css&apos;, function() &#123; return gulp.src(&apos;./style/*.scss&apos;) .pipe(sass()) .pipe(gulp.dest(&apos;./style/&apos;))&#125;); 在上面的代码中，我创建了一个叫做css的任务，该任务识别style文件夹中的sass文件，通过sass()将sass文件转换成css文件并保存在style中。 因此我们在项目根目录下创建style文件夹，文件夹里新建一个叫做test.scss的文件，随便写一点sass语法，就可以查看gulp能否编译成功 123456body &#123; margin: 0; div &#123; border: 1px solid red; &#125;&#125; 运行如下指令 1&gt; gulp css 在我的环境下， 1234➜ learn-gulp git:(master) ✗ gulp css[16:47:51] Using gulpfile ~/develop/me/learn-gulp/gulpfile.js[16:47:51] Starting &apos;css&apos;...[16:47:51] Finished &apos;css&apos; after 36 ms 成功运行之后，在style文件夹下面发现了一个新的css文件，test.css，这就是sass文件编译而来。 从上面的例子我们可以看出，gulp构建工具的关键就在gulpfile.js中，为了进一步感受gulp的魅力，我们下面引入更多的插件来管理css文件所有的插件在gulpfile.js中使用之前，都必须安装，安装通过npm install指令即可，插件名就是下面js中require后面的名字。 123456789101112131415161718192021222324252627282930313233&apos;use strict&apos;;var gulp = require(&apos;gulp&apos;);// css 相关插件var sass = require(&apos;gulp-sass&apos;); // 编译sassvar autoprefixer = require(&apos;gulp-autoprefixer&apos;); // 补全前缀var csscomb = require(&apos;gulp-csscomb&apos;); // 格式化css样式，排序var cssbeautify = require(&apos;gulp-cssbeautify&apos;); // 美化css样式var minifycss = require(&apos;gulp-minify-css&apos;); // 压缩css文件// 错误捕获var plumber = require(&apos;gulp-plumber&apos;);gulp.task(&apos;css&apos;, function() &#123; gulp.src(&apos;./style/*.scss&apos;) .pipe(plumber()) .pipe(sass()) .pipe(autoprefixer(&#123; browsers: [&apos;last 2 versions&apos;, &apos;Android &gt;= 4.0&apos;], cascade: true, //是否美化属性值 默认：true 像这样： //-webkit-transform: rotate(45deg); // transform: rotate(45deg); remove:true //是否去掉不必要的前缀 默认：true &#125;)) .pipe(csscomb()) .pipe(minifycss(&#123; aggressiveMerging: false, advanced: false, //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: &apos;ie7&apos;, //保留ie7及以下兼容写法 类型：String 默认：&apos;&apos;or&apos;*&apos; [启用兼容模式； &apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式] keepBreaks: true, //类型：Boolean 默认：false [是否保留换行] keepSpecialComments: &apos;*&apos; //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(gulp.dest(&apos;./style/&apos;)); &#125;); 这样的一个css任务，几乎就可以用于实际开发了。 但我们想要的最终效果是，只要我们保存了sass文件，那么gulp中我们定义的css任务就会自动执行，并且，浏览器中的页面，也会自动刷新。 而现在我们只能输入gulp css指令才能够完成编译，因此我们还需要做许多其他的配置。 gulp.watch 与 gulp-livereload插件 为了能够实现我们想要的效果，我们得借助插件gulp-livereload。通过这个插件，我们能够完成实现浏览器的自动刷新。想要实现这个效果，我们还得在chrome浏览器中安装livereload插件。如果能翻墙就很好办，如果不能翻墙那就自己想办法吧 - -！然后我们还要在gulpfile.js中的css任务中添加如下代码 123....pipe(gulp.dest(&apos;./style/&apos;)).pipe(livereload(&#123; quiet: true &#125;)); 为了能够检测到scss文件的变化，我们还得创建一个watch任务，用于监听文件变化 12345678gulp.task(&apos;watch&apos;, function() &#123; livereload.listen(); gulp.watch(&apos;./style/*.scss&apos;, [&apos;css&apos;]);&#125;) // 默认执行watch任务gulp.task(&apos;default&apos;, [&apos;watch&apos;]); 这样，就可以实现我们想要的效果了。在命令行中输入 1&gt; gulp 出现下面的提示 123456➜ learn-gulp git:(master) ✗ gulp[16:39:02] Using gulpfile ~/develop/me/learn-gulp/gulpfile.js[16:39:02] Starting &apos;watch&apos;...[16:39:02] Finished &apos;watch&apos; after 13 ms[16:39:02] Starting &apos;default&apos;...[16:39:02] Finished &apos;default&apos; after 7.08 μs 就表示gulp任务已经启动监听，然后在浏览器中点击一下livereload插件的图标，让中间的空心圆变成实心圆，改变scss文件并保存就能够自动刷新页面了。 文章的中间可能会有一些文件的创建没有说到，因此最好建议大家去github上的learn-gulp项目，所有的细节都在里面。配合本文的讲解，相信学会gulp不是难事。https://github.com/yangbo5207/learn-gulp这篇文章算是对gulp的一个简单入门，接下来的一篇文章我会为大家分析一下gulp的一些api，让大家能够轻松自如的编写gulpfile.js。","categories":[],"tags":[]},{"title":"获取任意一个元素中的第一个子元素","slug":"javascript/获取任意一个元素中的第一个子元素","date":"2016-08-04T16:00:00.000Z","updated":"2017-03-29T07:00:44.091Z","comments":true,"path":"2016/08/05/javascript/获取任意一个元素中的第一个子元素/","link":"","permalink":"http://yoursite.com/2016/08/05/javascript/获取任意一个元素中的第一个子元素/","excerpt":"","text":"12345678910111213141516171819/** * * @param element --任意一个元素 * @returns &#123;*&#125;----返回值是一个节点 */function getFirstElement(element) &#123; if (element.firstElementChild) &#123; return element.firstElementChild; &#125; else &#123; //IE8 不兼容 var node = element.firstChild; //判断当前的这个节点是不是标签 while (node &amp;&amp; node.nodeType != \"1\") &#123; //此时node不是标签,继续获取这个node的下一个兄弟节点 node = node.nextSibling; &#125; return node; &#125;&#125;","categories":[],"tags":[]},{"title":"gulp指南","slug":"前端工具/gulp指南","date":"2016-05-11T16:00:00.000Z","updated":"2017-03-12T12:41:36.231Z","comments":true,"path":"2016/05/12/前端工具/gulp指南/","link":"","permalink":"http://yoursite.com/2016/05/12/前端工具/gulp指南/","excerpt":"gulp指南 全局安装1npm install -g gulp-cli 查看版本号(验证是否安装成功) 1gulp --v","text":"gulp指南 全局安装1npm install -g gulp-cli 查看版本号(验证是否安装成功) 1gulp --v 本地安装 1npm install --save gulp 在根目录下创建一个 gulpfile.js 启动gulp 12直接写：gulp 变量名如果是变量名 default，就只写gulp 在gulpfile.js中写入一下内容 123456//加载gulp第三方包var gulp = require('gulp'); //定义一个吃饭的任务gulp.task(\"变量名\",function()&#123; console.log(\"吃饭\")&#125;) gulp.taskgulp.task(name [, deps][, fn]) 作用：定义各种不同的任务 gulp.task(name, fn) gulp.task(name, deps, fn) gulp.task(name, fn(cb)) gulp.task(name, deps, fn(cb)) 123 gulp.task(&apos;任务名&apos;,[可选的参数，是一个数组，用来声明当前任务的依赖任务], func(任务执行函数))* 1. func 中可以接收一个参数 cb ，用来控制任务依赖的执行流程的* 2. gulp.src 如何控制执行流程 12345678910一：普通任务​```jsgulp.task(&apos;a&apos;, function () &#123; console.log(&apos;1 aaa&apos;)&#125;)gulp.task(&apos;b&apos;, function () &#123; console.log(&apos;2 bbb&apos;)&#125;) 二：任务之间的依赖 1234567891011gulp.task('a', function (cb) &#123; setTimeout(function () &#123; console.log('1 aaa') cb() &#125;, 1000)&#125;)// b 任务依赖的 a 任务中的回调函数如果不调用，b 任务是不会执行的gulp.task('b', ['a'], function () &#123; console.log('2 bbb')&#125;) 三：gulp 流控制 12345678910gulp.task('a', function () &#123; // 当任务中是一个 gulp 流的时候则需要通过 return 来保证依赖中的执行顺序 return gulp.src() .pipe() // ...&#125;)gulp.task('b', ['a'], function () &#123; // doSomething&#125;) gulp.src 用来读文件12345678910111213141516171819 1. gulp.src 用来读文件- src参数：可以是字符串，- src参数也可以是数组：第一个参数表示想要拷贝的文件，第二个是不想要的文件 - `src/a.js` 指定具体文件； - `*` 匹配所有文件 例：`src/*.js` (包含src下的所有js文件)； - `**` 匹配0个或多个子文件夹 例：`src/**/*.js` (包含src的0个或多个子文件夹下的js文件)； - `&#123;&#125;` 匹配多个属性 例：`src/&#123;a,b&#125;.js` (包含a.js和b.js文件) src/*.&#123;jpg,png,gif&#125;(src下的所有jpg/png/gif文件)； - `!` 排除文件 例：`!src/a.js` (不包含src下的a.js文件)；```js//src参数：可以是字符串，//例子：查找所有的css：gulp.src(&apos;./src/css/**/*.css&apos;)gulp.task(&quot;变量名&quot;,function()&#123; gulp.src(&apos;./src/css/**/*.css&apos;) .pipe(gulp.dest(&apos;./dist/&apos;))&#125;) gulp.dest(path[, options]) gulp.dest 用来写文件作用：构建任务完成后资源存放的路径 gulp.watch(glob[, opts], tasks) 监视指定资源的改动，然后可以调用响应的任务处理 gulp.watch(glob [, opts, cb])gulp.src 和gulp.dest的例子12345678910111213141516171819202122232425262728/** * gulp.src 用来读文件 * gulp.dest 用来写文件 */var gulp = require('gulp')gulp.task('copy-index', function () &#123; // 通过 gulp.src() 读取到文件内容，然后通过 pipe() 方法，将读到的内容顺着管道流入 gulp.dest() 指定的目录中 gulp.src('./src/index.html') .pipe(gulp.dest('./dist/'))&#125;)gulp.task('copy-js', function () &#123; // gulp.src('./src/js/*.js') // .pipe(gulp.dest('./dist/js')) gulp.src('./src/js/**/*.js') .pipe(gulp.dest('./dist/js/'))&#125;)gulp.task('copy-css', function () &#123; // gulp.src(['./src/css/main.css', './src/css/login/login.css']) // .pipe(gulp.dest('./dist/css')) gulp.src(['./src/css/**/*.css', '!./src/css/haha.css']) .pipe(gulp.dest('./dist/css'))&#125;) 简单的例子：1234567891011var gulp = require('gulp'); //加载gulp第三方包//定义一个吃饭的任务gulp.task(\"eat\",function()&#123; console.log(\"吃饭\")&#125;)启动gulp 就直接写 gulp eat//default是一个比较特殊的人物名 可以直接通过 **gulp** 命令来执行gulp.task(\"default\",function()&#123; console.log(\"吃饭\")&#125;) 9.启动gulp 启动gulp 就直接写 gulp eat default是一个比较特殊的人物名 可以直接通过 gulp 命令来执行 10.编译less文件 编译LESS文件 1234567891011121314151617+ `npm install gulp-less`+ ```javascript var gulp = require(&apos;gulp&apos;) var less = require(&apos;gulp-less&apos;) gulp.task(&apos;less&apos;, function () &#123; gulp.src(&apos;./src/less/**/*.less&apos;) // 产生一坨数据 .pipe(less()) // 通过 pipe 将上一步 src 读取到的数据进入 less 插件，less 插件将处理过后的数据再次吐出来 .pipe(gulp.dest(&apos;./dist/css&apos;)) // 这里通过 pipe 管道接收上一个 less 吐出来的数据，经由 gulp.dest() 写入指定的目录路径 &#125;) // 该任务用来监视某个文件，当文件发生变化，则执行响应的任务 gulp.task(&apos;watch-less&apos;, [&apos;less&apos;], function () &#123; gulp.watch(&apos;./src/less/**/*.less&apos;, [&apos;less&apos;]) &#125;) 任务依赖 第一种情况：当异步加载的时候，需要在function中加callback 12345678910111213141516171819202122232425262728/** * 任务依赖 * gulp.task('任务名',[可选的参数，是一个数组，用来声明当前任务的依赖任务], func(任务执行函数)) * 1. func 中可以接收一个参数 cb ，用来控制任务依赖的执行流程的 * 2. gulp.src 如何控制执行流程 */var gulp = require('gulp')// 当依赖了 a 任务的任务 ab 在执行的时候，会先来执行 a// 发现 a 的执行函数有一个参数：callback，则 ab 必须等待 a 内部调用了 callback 才会继续执行gulp.task('a', function (callback) &#123; console.log('a开始了') setTimeout(function () &#123; console.log('a 中的定时器到了：aaa') callback() // callback() 调用就是告诉依赖了 a 任务的某个任务。我执行完了，你可以继续了 &#125;, 1000) console.log('a结束了')&#125;)gulp.task('b', function () &#123; console.log('bbb')&#125;)// 这里的任务的依赖是并行执行的，ab 任务不会等待 a 或者 b 完全执行结束才执行自己gulp.task('ab', ['a', 'b'], function () &#123; console.log('aaabbb')&#125;) 第二种情况 1234567891011121314151617/*** 对于普通的 API，通过 callback 来控制流程* 而对于 gulp 的原生的读写文件API，通过 return 实现流程控制*/ var gulp = require('gulp') var less = require('gulp-less') var cssnano = require('gulp-cssnano') var del = require('del') gulp.task('clear', function (callback) &#123;del('./dist/') .then(function () &#123; callback() &#125;) }) gulp.task(‘less’, [‘clear’], function () { // 如果是依赖 less 的任务，需要依赖于 less 的结果 // 则必须在 gulp.src() 之前加入 return 才可以实现流程控制 return gulp.src(‘./src/less/*/.less’) .pipe(less()) .pipe(gulp.dest(&apos;./dist/css/&apos;)) }) gulp.task(&apos;cssmin&apos;, [&apos;less&apos;], function () { gulp.src(&apos;./dist/css/**/*.css&apos;) .pipe(cssnano()) .pipe(gulp.dest(&apos;./dist/mincss&apos;)) }) 压缩 css压缩 gulp-cssnano 先安装 npm install gulp-cssnano 然后引用 js 压缩 gulp-uglify 先安装 npm install gulp-uglify 然后引用 123var gulp = require(&apos;gulp&apos;)var less = require(&apos;gulp-less&apos;)var cssnano = require(&apos;gulp-cssnano&apos;) ​ 常用插件 插件名称 作用 del 删除文件或文件夹 gulp-less 编译LESS文件 gulp-rname 重命名文件 gulp-imagemin 图片压缩 gulp-uglify 压缩Javascript gulp-concat 合并 js 文件 gulp-concat-css 合并 css 文件 gulp-cssnano 压缩 css gulp-htmlmin 压缩HTML gulp-nunjucks 模板引擎 gulp-rev 添加版本号 gulp-rev-collector 内容替换 gulp-useref gulp-if gulp-load-plugins 依赖自动加载 gulp-useref 自动合并打包处理 gulp-wrap 包装内容 gulp-angular-templatecache AngularJS 模板缓存 browser-sync 和 gulp 配合使用实现文件改变执行某个任务后自动刷新 yargs 获取命令行参数 gulp-if 根据判断执行某个插件 http-proxy-middleware http 代理插件 ## 参考网址 官方：http://gulpjs.com/ 中文官网：http://www.gulpjs.com.cn/ npm：https://www.npmjs.com/package/gulp Github：https://github.com/gulpjs/gulp Gitbook：https://wizardforcel.gitbooks.io/gulp-doc/content/2.html","categories":[],"tags":[]},{"title":"三大系列——element元素结点属性","slug":"javascript/三大系列——element元素结点属性","date":"2016-04-14T16:00:00.000Z","updated":"2017-03-24T01:56:08.966Z","comments":true,"path":"2016/04/15/javascript/三大系列——element元素结点属性/","link":"","permalink":"http://yoursite.com/2016/04/15/javascript/三大系列——element元素结点属性/","excerpt":"","text":"之前看过这样的文章，总结不全，三大系列相当重要，结合文章加自己的理解整理了整理 区别client、offset、scroll系列以及event的几个距离属性 offset系列offsetWidth 和offsetHeightelement.offsetWidth是一个只读属性，它包括了：css width + padding+border+垂直滚动条宽度 这里的滚动条就是单纯滚动条的意思，不包括不可见的部分哦。 而element.offsetHeight与之类似，只是改为垂直方向而已。 1&lt;!--more--&gt; offsetParentelement.offsetParent是一个只读属性，返回一个对象的引用，这个引用指向了element（调用offsetParent）的最近一个使用了定位（absolute、relative）的父元素，如果没有定位了的父元素，则指向根元素（标准模式下为 html；quirks 模式下为 body）。 兼容性： 在 Webkit 中，如果元素为隐藏的（该元素或其祖先元素的 style.display 为 “none”），或者该元素的 style.position 被设为 “fixed”，则该属性返回 null。 在 IE 9 中，如果该元素的 style.position 被设置为 “fixed”，则该属性返回 null。（display:none 无影响。） 3.offsetTop和offsetLeft element.offsetTop 和 element.offsetLeft 都是相对于offsetParent的内边距（外）边界的。 也就是返回对象元素边界的左上角顶点相对于offsetParent的左上角顶点的水平偏移量。这里，元素对象左上角顶点是要从border开始算（如果有的话，即border边界距离offsetParent padding边界的距离，不是从从元素的margin开始算），offsetParent的左上角是指其padding边界。 参考资料： 前端攻城狮学习笔记九：让你彻底弄清offset HTMLElement.offsetParent client系列clientHeight和clientWidthelement.clientHeight表示元素可视区域的高度，包括可视区域中元素的 CSS height+padding 不包括边框、滚动条、不可见部分、margin。 clientWidth类似，只不过是水平方向。 clientLeft和clientTop是元素 padding外边界与父元素的padding边界的距离-元素的offsetLeft值，就等于元素的左边框宽度。？？？不知道理解对没 clientTop与之类似。 scroll系列scrollHeight和scrollWidthelement.scrollHeight属性是只读的，它包括： 可见CSS高度+padding+border+由于overflow设置为隐藏或者scroll而不可见的内容高度。 可看出和offsetHeight的区别就是多了个不可见内容区高度。scrollWidth与之类似。 scrollTop和scrollLeft即是被scroll了的内容区域的高度和宽度，隐藏不可见的内容区域。 注意： 元素设置了overflow: scroll，滚动条是占据了元素原来CSS宽度的一部分，即加了滚动条后，元素CSS中定义的属性width=滚动条宽度+content 宽度。边框是加在滚动条外面的，而padding则是加在滚动条内部，内容区之外的。 一个盒子设置了margin-top，是和别的盒子间的垂直距离，这个别的盒子不包括父盒子，也就是说，内部盒子顶部和父盒子边界的距离不变，而是整个父盒子顶部都和更外部的环境相距了margin-top值的距离。 参考资料： Mozilla文档上的图示描述得很明白 https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollHeight event事件对象属性 下面几个是event事件对象的属性，可获取鼠标的位置： 1.clientX，clientY 表示鼠标位置距离可视窗口边缘的距离。它们是事件对象的属性。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。 2.pageX，pageY 表示鼠标位置距离整个文档页面边缘（左和上边缘）的距离 3.screenX，screenY 表示鼠标位置距离屏幕边缘的距离 4.offsetX，offsetY： 鼠标相对于事件源元素（srcElement）的X,Y坐标，只有IE事件有这2个属性，标准事件没有对应的属性。 来看个小例子，跟随鼠标的提示框： //css #info {position:absolute;} //html //js document.onmousemove=function(ev){ var oEvent=ev||event; var info=document.getElementById(‘info’); //获取不可见内容高度 var scrollTop=document.documentElement.scrollTop|| document.body.scrollTop//???混杂模式和标准模式下都能工作？ info.style.left=oEvent.clientX+’px’; info.style.top=oEvent.clientY+scrollTop+’px’; //可视区高度+scrolled的高度 } document.documentElement指向document对象的根元素，在html文档中就是html元素。 经验：只要在用到clientX和clientY的地方都最好加上scroll值。 scroll 获取元素内容的大小和位置 滚动条滚动距离 层中设置文字内容,然后获取层的scrollHeight 设置层中的overflow:auto 查看scrollTop 区别：1.scrollTop : 滚动条滚动距离 说明：chrome下他会以为滚动条是文档元素的，所以需要做兼容 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; scrollHeight 返回整个元素的高度+padding（包括子元素把父元素撑开隐蔽的地方） 说明:scrollHeight问题比较大 1、当子元素的高度大于父元素高度：标准浏览器下包含子元素样式高+padding+margin+border+父元素padding-top的值，ie7以下包含子元素样式高+padding+margin+border+父元素padding-top和padding-bottom 2、当子元素的高度小于父元素高度：标准浏览器下包含父元素样式高+padding，ie7以下只计算子元素的高度+父元素的padding 二、pageX和pageY e.clientX和e.clientY是可视区域的坐标 e.pageX和e.pageY才是真正的文档的坐标 兼容的写法是: ​e.client+document.body.scrollTop==e.pageY","categories":[],"tags":[]},{"title":"返回指定的日期格式","slug":"javascript/返回指定时间格式","date":"2016-04-09T16:00:00.000Z","updated":"2017-03-29T06:27:47.655Z","comments":true,"path":"2016/04/10/javascript/返回指定时间格式/","link":"","permalink":"http://yoursite.com/2016/04/10/javascript/返回指定时间格式/","excerpt":"","text":"1234567891011121314151617181920212223242526/** * 获取当前的日期，显示指定的格式 * @param time----&gt;日期对象 * @returns &#123;string&#125; 返回指定字符串的日期格式 */function getDayTime(time) &#123; //new Date() 获取今天当前的日期 //获取年份 var year = time.getFullYear(); //获取月份 var month = time.getMonth() + 1; //获取当天日期 var day = time.getDate(); //获取时 var hour = time.getHours(); //获取分 var minutes = time.getMinutes(); //获取秒 var second = time.getSeconds(); month = month &lt; 10 ? \"0\" + month : month; day = day &lt; 10 ? \"0\" + day : day; hour = hour &lt; 10 ? \"0\" + hour : hour; minutes = minutes &lt; 10 ? \"0\" + minutes : minutes; second = second &lt; 10 ? \"0\" + second : second; return year + \"年\" + month + \"月\" + day + \"日 \" + second + \":\" + minutes + \":\" + second;&#125;","categories":[],"tags":[]},{"title":"Flex布局新旧混合写法","slug":"css/Flex布局新旧混合写法详解（兼容微信）","date":"2015-06-17T16:00:00.000Z","updated":"2017-03-05T10:47:16.474Z","comments":true,"path":"2015/06/18/css/Flex布局新旧混合写法详解（兼容微信）/","link":"","permalink":"http://yoursite.com/2015/06/18/css/Flex布局新旧混合写法详解（兼容微信）/","excerpt":"首先还是从两个版本的语法开始讲吧，这里还是假设flex容器为 .box ，子元素为 .item 。 旧语法篇 定义容器的display属性 .box{ display: -moz-box; /*Firefox*/ display: -webkit-box; /*Safari,Opera,Chrome*/ display: box; }","text":"首先还是从两个版本的语法开始讲吧，这里还是假设flex容器为 .box ，子元素为 .item 。 旧语法篇 定义容器的display属性 .box{ display: -moz-box; /*Firefox*/ display: -webkit-box; /*Safari,Opera,Chrome*/ display: box; } 容器属性 1.box-pack 属性 box-pack定义子元素主轴对齐方式。 .box{ -moz-box-pack: center; /*Firefox*/ -webkit-box-pack: center; /*Safari,Opera,Chrome*/ box-pack: center; } box-pack属性总共有4个值： .box{ box-pack: start | end | center | justify; /*主轴对齐：左对齐（默认） | 右对齐 | 居中对齐 | 左右对齐*/ } 2.box-align 属性 box-align定义子元素交叉轴对齐方式。 .box{ -moz-box-align: center; /*Firefox*/ -webkit-box-align: center; /*Safari,Opera,Chrome*/ box-align: center; } box-align属性总共有5个值： .box{ box-align: start | end | center | baseline | stretch; /*交叉轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 文本基线对齐 | 上下对齐并铺满*/ } 3.box-direction 属性 box-direction定义子元素的显示方向。 .box{ -moz-box-direction: reverse; /*Firefox*/ -webkit-box-direction: reverse; /*Safari,Opera,Chrome*/ box-direction: reverse; } box-direction属性总共有3个值： .box{ box-direction: normal | reverse | inherit; /*显示方向：默认方向 | 反方向 | 继承子元素的 box-direction*/ } 4.box-orient 属性 box-orient定义子元素是否应水平或垂直排列。 .box{ -moz-box-orient: horizontal; /*Firefox*/ -webkit-box-orient: horizontal; /*Safari,Opera,Chrome*/ box-orient: horizontal; } box-orient属性总共有5个值： .box{ box-orient: horizontal | vertical | inline-axis | block-axis | inherit; /*排列方向：水平 | 垂直 | 行内方式排列（默认） | 块方式排列 | 继承父级的box-orient*/ } 5.box-lines 属性 box-lines定义当子元素超出了容器是否允许子元素换行。 .box{ -moz-box-lines: multiple; /*Firefox*/ -webkit-box-lines: multiple; /*Safari,Opera,Chrome*/ box-lines: multiple; } box-lines属性总共有2个值： .box{ box-lines: single | multiple; /*允许换行：不允许（默认） | 允许*/ } 子元素属性 1.box-flex 属性 box-flex定义是否允许当前子元素伸缩。 .item{ -moz-box-flex: 1.0; /*Firefox*/ -webkit-box-flex: 1.0; /*Safari,Opera,Chrome*/ box-flex: 1.0; } box-flex属性使用一个浮点值： .item{ box-flex: &lt;value&gt;; /*伸缩：&lt;一个浮点数，默认为0.0，即表示不可伸缩，大于0的值可伸缩，柔性相对&gt;*/ } 2.box-ordinal-group 属性 box-ordinal-group定义子元素的显示次序，数值越小越排前。 .item{ -moz-box-ordinal-group: 1; /*Firefox*/ -webkit-box-ordinal-group: 1; /*Safari,Opera,Chrome*/ box-ordinal-group: 1; } box-direction属性使用一个整数值： .item{ box-ordinal-group: &lt;integer&gt;; /*显示次序：&lt;一个整数，默认为1，数值越小越排前&gt;*/ } 新版语法 定义容器的display属性 .box{ display: -webkit-flex; /*webkit*/ display: flex; } /行内flex/ .box{ display: -webkit-inline-flex; /*webkit*/ display:inline-flex; } 容器样式 .box{ flex-direction: row | row-reverse | column | column-reverse; /*主轴方向：左到右（默认） | 右到左 | 上到下 | 下到上*/ flex-wrap: nowrap | wrap | wrap-reverse; /*换行：不换行（默认） | 换行 | 换行并第一行在下方*/ flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; /*主轴方向和换行简写*/ justify-content: flex-start | flex-end | center | space-between | space-around; /*主轴对齐方式：左对齐（默认） | 右对齐 | 居中对齐 | 两端对齐 | 平均分布*/ align-items: flex-start | flex-end | center | baseline | stretch; /*交叉轴对齐方式：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/ align-content: flex-start | flex-end | center | space-between | space-around | stretch; /*多主轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 上下平均分布*/ } 子元素属性 .item{ order: &lt;integer&gt;; /*排序：数值越小，越排前，默认为0*/ flex-grow: &lt;number&gt;; /* default 0 */ /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: &lt;number&gt;; /* default 1 */ /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/ flex-basis: &lt;length&gt; | auto; /* default auto */ /*固定大小：默认为0，可以设置px值，也可以设置百分比大小*/ flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ] /*flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，*/ align-self: auto | flex-start | flex-end | center | baseline | stretch; /*单独对齐方式：自动（默认） | 顶部对齐 | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/ } 兼容写法 首先是定义容器的 display 属性： .box{ display: -webkit-box; /* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */ display: -moz-box; /* 老版本语法: Firefox (buggy) */ display: -ms-flexbox; /* 混合版本语法: IE 10 */ display: -webkit-flex; /* 新版本语法: Chrome 21+ */ display: flex; /* 新版本语法: Opera 12.1, Firefox 22+ */ } 由于旧版语法并没有列入W3C标准，所以这里不用写 display:box ，下面的语法也是一样的。 这里还要注意的是，如果子元素是行内元素，在很多情况下都要使用 display:block 或 display:inline-block 把行内子元素变成块元素（例如使用 box-flex 属性），这也是旧版语法和新版语法的区别之一。 子元素主轴对齐方式 .box{ -webkit-box-pack: center; -moz-justify-content: center; -webkit-justify-content: center; justify-content: center; } 这里旧版语法有4个参数，而新版语法有5个参数，兼容写法新版语法的 space-around 是不可用的： .box{ box-pack: start | end | center | justify; /*主轴对齐：左对齐（默认） | 右对齐 | 居中对齐 | 左右对齐*/ justify-content: flex-start | flex-end | center | space-between | space-around; /*主轴对齐方式：左对齐（默认） | 右对齐 | 居中对齐 | 两端对齐 | 平均分布*/ } 子元素交叉轴对齐方式 .box{ -webkit-box-align: center; -moz-align-items: center; -webkit-align-items: center; align-items: center; } 这里的参数除了写法不同，其实是功能是一样的： .box{ box-align: start | end | center | baseline | stretch; /*交叉轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 文本基线对齐 | 上下对齐并铺满*/ align-items: flex-start | flex-end | center | baseline | stretch; /*交叉轴对齐方式：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/ } 子元素的显示方向 子元素的显示方向可通过 box-direction + box-orient + flex-direction 实现，下面请看实例： 左到右 .box{ -webkit-box-direction: normal; -webkit-box-orient: horizontal; -moz-flex-direction: row; -webkit-flex-direction: row; flex-direction: row; } 右到左 .box{ -webkit-box-pack: end; -webkit-box-direction: reverse; -webkit-box-orient: horizontal; -moz-flex-direction: row-reverse; -webkit-flex-direction: row-reverse; flex-direction: row-reverse; } 这里补充说明一点： box 写法的 box-direction 只是改变了子元素的排序，并没有改变对齐方式，需要新增一个 box-pack 来改变对齐方式。 上到下 .box{ -webkit-box-direction: normal; -webkit-box-orient: vertical; -moz-flex-direction: column; -webkit-flex-direction: column; flex-direction: column; } 下到上 .box{ -webkit-box-pack: end; -webkit-box-direction: reverse; -webkit-box-orient: vertical; -moz-flex-direction: column-reverse; -webkit-flex-direction: column-reverse; flex-direction: column-reverse; } 是否允许子元素伸缩 .item{ -webkit-box-flex: 1.0; -moz-flex-grow: 1; -webkit-flex-grow: 1; flex-grow: 1; } .item{ -webkit-box-flex: 1.0; -moz-flex-shrink: 1; -webkit-flex-shrink: 1; flex-shrink: 1; } 上面是允许放大，box语法中 box-flex 如果不是0就表示该子元素允许伸缩，而flex是分开的，上面 flex-grow 是允许放大（默认不允许），下面的 flex-shrink 是允许缩小（默认允许）。box-flex 默认值为0，也就是说，在默认的情况下，在两个浏览器中的表现是不一样的： 这里还有一点，就是新旧语法的算法是不一样的，假设 box-flex 的值不等于0，旧语法中，如果有多余的空间，box-flex 的值越大，说明空白部分的占比越多，反之亦然： 而新版的语法中，放大的比例是直接按 flex-grow 的值来分配的，flex-grow 的缩放会覆盖 flex-shrink:0，看例子： 参数： .item{ box-flex: &lt;value&gt;; /*伸缩：&lt;一个浮点数，默认为0.0，即表示不可伸缩，大于0的值可伸缩，柔性相对&gt;*/ flex-grow: &lt;number&gt;; /* default 0 */ /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: &lt;number&gt;; /* default 1 */ /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/ } 子元素的显示次序 .item{ -webkit-box-ordinal-group: 1; -moz-order: 1; -webkit-order: 1; order: 1; }","categories":[],"tags":[]},{"title":"Javascript 中 apply、call、bind","slug":"javascript/深入浅出妙用 Javascript 中 apply、call、bind","date":"2015-04-09T16:00:00.000Z","updated":"2017-03-05T07:37:04.020Z","comments":true,"path":"2015/04/10/javascript/深入浅出妙用 Javascript 中 apply、call、bind/","link":"","permalink":"http://yoursite.com/2015/04/10/javascript/深入浅出妙用 Javascript 中 apply、call、bind/","excerpt":"通过这篇文章，能够清晰的提升对apply、call、bind的认识 apply、call 在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。 JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。","text":"通过这篇文章，能够清晰的提升对apply、call、bind的认识 apply、call 在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。 JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。 先来一个栗子： function fruits() {} fruits.prototype = { color: “red”, say: function() { console.log(“My color is “ + this.color); } } var apple = new fruits; apple.say(); //My color is red 但是如果我们有一个对象banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法： banana = { color: “yellow” } apple.say.call(banana); //My color is yellow apple.say.apply(banana); //My color is yellow 所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本栗子中banana没有say方法），但是其他的有（本栗子中apple有say方法），我们可以借助call或apply用其它对象的方法来操作。 apply、call 的区别 对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下： var func = function(arg1, arg2) { }; 就可以通过如下方式来调用： func.call(this, arg1, arg2); func.apply(this, [arg1, arg2]) 其中 this 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call 。 而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。 为了巩固加深记忆，下面列举一些常用用法： 1、数组之间追加 var array1 = [12 , “foo” , {name “Joe”} , -2458]; var array2 = [“Doe” , 555 , 100]; Array.prototype.push.apply(array1, array2); / array1 值为 [12 , “foo” , {name “Joe”} , -2458 , “Doe” , 555 , 100] / 2、获取数组中的最大值和最小值 var numbers = [5, 458 , 120 , -215 ]; var maxInNumbers = Math.max.apply(Math, numbers), //458 maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458 number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。 3、验证是否是数组（前提是toString()方法没有被重写过） functionisArray(obj){ returnObject.prototype.toString.call(obj) === &apos;[object Array]&apos; ; } 4、类（伪）数组使用数组方法 var domNodes = Array.prototype.slice.call(document.getElementsByTagName(“*”)); Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。 但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。 深入理解运用apply、call 下面就借用一道面试题，来更深入的去理解下 apply 和 call 。 定义一个 log 方法，让它可以代理 console.log 方法，常见的解决方法是： function log(msg) { console.log(msg); } log(1); //1 log(1,2); //1 上面方法可以解决最基本的需求，但是当传入参数的个数是不确定的时候，上面的方法就失效了，这个时候就可以考虑使用 apply 或者 call，注意这里传入多少个参数是不确定的，所以使用apply是最好的，方法如下： function log(){ console.log.apply(console, arguments); }; log(1); //1 log(1,2); //1 2 接下来的要求是给每一个 log 消息添加一个”(app)”的前辍，比如： log(“hello world”); //(app)hello world 该怎么做比较优雅呢?这个时候需要想到arguments参数是个伪数组，通过 Array.prototype.slice.call 转化为标准数组，再使用数组方法unshift，像这样： function log(){ var args = Array.prototype.slice.call(arguments); args.unshift(&apos;(app)&apos;); console.log.apply(console, args); }; bind 说完了 apply 和 call ，再来说说bind。bind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。 MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。 像这样： var foo = { bar : 1, eventBind: function(){ var _this = this; $(‘.someClass’).on(‘click’,function(event) { / Act on the event / console.log(_this.bar); //1 }); } } 由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题： var foo = { bar : 1, eventBind: function(){ $(‘.someClass’).on(‘click’,function(event) { / Act on the event / console.log(this.bar); //1 }.bind(this)); } } 在上述代码里，bind() 创建了一个函数，当这个click事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用bind()时传入的参数）。因此，这里我们传入想要的上下文 this(其实就是 foo )，到 bind() 函数中。然后，当回调函数被执行的时候， this 便指向 foo 对象。再来一个简单的栗子： var bar = function(){ console.log(this.x); } bar(); // undefined var func = bar.bind(foo); func(); // 3 这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。 有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？像这样： var bar = function(){ console.log(this.x); } var foo = { x:3 } var sed = { x:4 } var func = bar.bind(foo).bind(sed); func(); //? var fiv = { x:5 } var func = bar.bind(foo).bind(sed).bind(fiv); func(); //? 答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在Javascript中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。 apply、call、bind比较 那么 apply、call、bind 三者相比较，之间又有什么异同呢？何时使用 apply、call，何时使用 bind 呢。简单的一个栗子： var obj = { x: 81, }; var foo = { getX: function() { return this.x; } } console.log(foo.getX.bind(obj)()); //81 console.log(foo.getX.call(obj)); //81 console.log(foo.getX.apply(obj)); //81 三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。 也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。 再总结一下： apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind是返回对应函数，便于稍后调用；apply、call则是立即调用 。","categories":[],"tags":[]},{"title":"七种CSS方式让一个容器水平垂直居中","slug":"css/七种CSS方式让一个容器水平垂直居中","date":"2015-03-19T16:00:00.000Z","updated":"2017-03-05T09:02:39.968Z","comments":true,"path":"2015/03/20/css/七种CSS方式让一个容器水平垂直居中/","link":"","permalink":"http://yoursite.com/2015/03/20/css/七种CSS方式让一个容器水平垂直居中/","excerpt":"阅读目录方法一：position加margin方法二： diaplay:table-cell方法三：position加 transform方法四：flex;align-items: center;justify-content: center方法五：display:flex;margin:auto方法六：纯position方法七：兼容低版本浏览器，不固定宽高","text":"阅读目录方法一：position加margin方法二： diaplay:table-cell方法三：position加 transform方法四：flex;align-items: center;justify-content: center方法五：display:flex;margin:auto方法六：纯position方法七：兼容低版本浏览器，不固定宽高 总结这种css布局平时用的比较多，也是面试题常出的一个题，网上一搜一大丢，不过还是想自己总结一下。 这种方法比较多，本文只总结其中的几种，以便加深印象。效果图都为这个： 方法一：position加margin1234567/**html**/&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /**css**/.wrap &#123; width: 200px; height: 200px; background: yellow; position: relative; &#125;.wrap .center &#123; width: 100px; height: 100px; background: green; margin: auto; position: absolute; left: 0; right: 0; top: 0; bottom: 0; &#125; 兼容性：主流浏览器均支持，IE6不支持 方法二： diaplay:table-cell1234567/**html**/&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /*css*/.wrap &#123; width: 200px; height: 200px; background: yellow; display: table-cell; vertical-align: middle; text-align: center; &#125; .center &#123; display: inline-block; vertical-align: middle; width: 100px; height: 100px; background: green; &#125; 兼容性：由于display:table-cell的原因，IE6\\7不兼容 方法三：position加 transform1234567/**html**/&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /*css*/.wrap &#123; position: relative; background: yellow; width: 200px; height: 200px; &#125;.center &#123; position: absolute; background: green; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%); width: 100px; height: 100px; &#125; 兼容性：ie9以下不支持 transform，手机端表现的比较好。 方法四：flex;align-items: center;justify-content: center1234567/**html**/&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /*css*/.wrap &#123; background: yellow; width: 200px; height: 200px; display: flex; align-items: center; justify-content: center; &#125;.center &#123; background: green; width: 100px; height: 100px; &#125; 移动端首选 方法五：display:flex;margin:auto1234567/**html**/&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /*css*/.wrap &#123; background: yellow; width: 200px; height: 200px; display: flex; &#125;.center &#123; background: green; width: 100px; height: 100px; margin: auto; &#125; 移动端首选 方法六：纯position12345678910/**html**/&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /*css*/.wrap &#123; background: yellow; width: 200px; height: 200px; position: relative; &#125;/**方法一**/.center &#123; background: green; position: absolute; width: 100px; height: 100px; left: 50px; top: 50px; &#125;/**方法二**/.center &#123; background: green; position: absolute; width: 100px; height: 100px; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; &#125; 兼容性：适用于所有浏览器 方法六中的方法一计算公式如下： 子元素（conter）的left值计算公式：left=(父元素的宽 - 子元素的宽 ) / 2=(200-100) / 2=50px;子元素（conter）的top值计算公式：top=(父元素的高 - 子元素的高 ) / 2=(200-100) / 2=50px; 方法二计算公式：left值固定为50%;子元素的margin-left= -（子元素的宽/2）=-100/2= -50px;top值也一样，固定为50% 子元素的margin-top= -（子元素的高/2）=-100/2= -50px; 方法七：兼容低版本浏览器，不固定宽高12345678910111213&lt;!-- html --&gt;&lt;div class=\"table\"&gt; &lt;div class=\"tableCell\"&gt; &lt;div class=\"content\"&gt;不固定宽高，自适应&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; /*css*/.table &#123; height: 200px; /*高度值不能少*/ width: 200px; /*宽度值不能少*/ display: table; position: relative; float: left; background: yellow; &#125;.tableCell &#123; display: table-cell; vertical-align: middle; text-align: center; *position: absolute; padding: 10px; *top: 50%; *left: 50%; &#125;.content &#123; *position: relative; *top: -50%; *left: -50%; background: green; &#125; 暂时总结上面的七种，这种方法太多，其实只要习惯了其中的一两种也就够用了。 总结如果是移动端，那么用方法四和方法五是比较方便的。而且支持不固定宽高的情况，快、准、狠 也就是用 flex; align-items: center; justify-content: center; 1234567891011121314151617181920&lt;!-- html --&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /* css */.wrap &#123; background: yellow; width: 200px; height: 200px; display: flex; align-items: center; justify-content: center;&#125; .center &#123; background: green; width: 100px; height: 100px;&#125; 或者display:flex;margin:auto; 12345678910111213141516171819&lt;!-- html --&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /* css */.wrap &#123; background: yellow; width: 200px; height: 200px; display: flex;&#125; .center &#123; background: green; width: 100px; height: 100px; margin: auto;&#125; 如果是PC端，要考虑兼容性的话。方法六是不错滴，也就是纯position。 123456789101112131415161718192021222324252627282930313233&lt;!-- html --&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /* css */.wrap &#123; background: yellow; width: 200px; height: 200px; position: relative;&#125;/**方法一**/.center &#123; background: green; position: absolute; width: 100px; height: 100px; left: 50px; top: 50px; &#125;/**方法二**/.center &#123; background: green; position: absolute; width: 100px; height: 100px; left: 50%; top: 50%; margin-left:-50px; margin-top:-50px;&#125; 如果PC端的中间的元素高度不固定，那么就用方法七即可，代码就不复制了 这种css元素垂直的如果真的要总结起来，应该有十几二十几种。不过也没必要全部掌握吧，只要大概了解一些，用起来没有副作用就行。","categories":[],"tags":[]},{"title":"JS中几种继承模型","slug":"javascript/JS中几种继承模型","date":"2015-02-04T16:00:00.000Z","updated":"2017-03-05T06:49:14.736Z","comments":true,"path":"2015/02/05/javascript/JS中几种继承模型/","link":"","permalink":"http://yoursite.com/2015/02/05/javascript/JS中几种继承模型/","excerpt":"一、 扩展原型对象实现继承123function Person()&#123;&#125; Person.prototype.say=function()&#123;&#125;; var p1=new Person();","text":"一、 扩展原型对象实现继承123function Person()&#123;&#125; Person.prototype.say=function()&#123;&#125;; var p1=new Person(); 二、 替换原型对象实现继承123456Person.prototype=&#123; constructor:Person, run:function()&#123;&#125;&#125;;var p2=new Person();console.log(p1.__proto__===p2.__proto__);//false 三、 替换原型对象实现继承混入(拷贝)继承:$.extend 将其中一个对象的属性和方法拷贝到另外一个对象中1234567var o1=&#123;name:&quot;zhangsan&quot;,age:20&#125;;var o2=&#123;gender:&quot;男&quot;&#125;;for (var key in o1) &#123; //key表示每一次遍历的属性的名称 o2[key]=o1[key];&#125; 混入继承的封装12345678910111213/** * 混入继承 * @param target 接受数据的对象 * @param source 提供数据的对象 * @returns &#123;*&#125; */function extend(target,source)&#123; for (var key in source) &#123; //key表示每一次遍历的属性的名称 target[key]=source[key]; &#125; return target;&#125; 四、 原型混入继承利用混入继承的原理向原型对象中添加属性和方法连接上面的封装1extend(Person.prototype,&#123;jump:function()&#123;&#125;&#125;); 五、原型式继承已知一个对象，需要创建一个新的对象，让新的对象继承自原来的对象特点：在创建对象的时候不需要关心对象的构造函数123456var o3=&#123; age:20 &#125;;function F()&#123;&#125;F.prototype=o3;//让F的实例继承自o3var o4=new F();//o4.__proto__:F.prototype:o3var o5=new F();//o5.__proto__:o3var o6=Object.create(o3); 六、寄生继承123456789101112131415//6.1、寄生继承function create(name)&#123; var obj=Object.create(null); obj.name=name; return obj;&#125;//6.2、寄生构造函数：function Animal(name,color)&#123; var obj=&#123;&#125;; obj.name=name; obj.color=color; return obj;&#125;var cat=new Animal();","categories":[],"tags":[]},{"title":"JS 原型与原型链详解","slug":"javascript/JS 原型与原型链详解","date":"2015-01-13T16:00:00.000Z","updated":"2017-03-05T06:49:10.517Z","comments":true,"path":"2015/01/14/javascript/JS 原型与原型链详解/","link":"","permalink":"http://yoursite.com/2015/01/14/javascript/JS 原型与原型链详解/","excerpt":"一. 普通对象与函数对象 JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是 JS 自带的函数对象。下面举例说明","text":"一. 普通对象与函数对象 JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是 JS 自带的函数对象。下面举例说明 var o1 = {}; var o2 =new Object(); var o3 = new f1(); function f1(){}; var f2 = function(){}; var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;); console.log(typeof Object); //function console.log(typeof Function); //function console.log(typeof f1); //function console.log(typeof f2); //function console.log(typeof f3); //function console.log(typeof o1); //object console.log(typeof o2); //object console.log(typeof o3); //object 在上面的例子中 o1 o2 o3 为普通对象，f1 f2 f3 为函数对象。怎么区分，其实很简单，凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。 一定要分清楚普通对象和函数对象，下面我们会常常用到它。 二. 构造函数 我们先复习一下构造函数的知识： function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function() { alert(this.name) } } var person1 = new Person(&apos;Zaxlct&apos;, 28, &apos;Software Engineer&apos;); var person2 = new Person(&apos;Mick&apos;, 23, &apos;Doctor&apos;); 上面的例子中 person1 和 person2 都是 Person 的实例。这两个实例都有一个 constructor （构造函数）属性，该属性（是一个指针）指向 Person。 即： console.log(person1.constructor == Person); //true console.log(person2.constructor == Person); //true 我们要记住两个概念（构造函数，实例）： person1 和 person2 都是 构造函数 Person 的实例 一个公式： 实例的构造函数属性（constructor）指向构造函数。 三. 原型对象 在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象。（先用不管什么是 proto 第二节的课程会详细的剖析） function Person() {} Person.prototype.name = &apos;Zaxlct&apos;; Person.prototype.age = 28; Person.protetype.job = &apos;Software Engineer&apos;; Person.prototype.sayName = function() { alert(this.name); } var person1 = new Person(); person1.sayName(); // &apos;Zaxlct&apos; var person2 = new Person(); person2.sayName(); // &apos;Zaxlct&apos; console.log(person1.sayname == person2.sayname); //true 我们得到了本文第一个「定律」： 每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性 那什么是原型对象呢？ 我们把上面的例子改一改你就会明白了： Person.prototype = { name: &apos;Zaxlct&apos;, age: 28, job: &apos;Software Engineer&apos;, sayName: function() { alert(this.name); } } 原型对象，顾名思义，它就是一个普通对象（废话 = =!）。从现在开始你要牢牢记住原型对象就是 Person.prototype ，如果你还是害怕它，那就把它想想成一个字母 A： var A = Person.prototype 在上面我们给 A 添加了 四个属性：name、age、job、sayName。其实它还有一个默认的属性：constructor 在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person） 上面这句话有点拗口，我们「翻译」一下：A 有一个默认的 constructor 属性，这个属性是一个指针，指向 Person。即： Person.prototype.constructor == Person 在上面第二小节《构造函数》里，我们知道实例的构造函数属性（constructor）指向构造函数 ：person1.constructor == Person 这两个「公式」好像有点联系： person1.constructor == Person Person.prototype.constructor == Person person1 为什么有 constructor 属性？那是因为 person1 是 Person 的实例。 那 Person.prototype 为什么有 constructor 属性？？同理， Person.prototype （你把它想象成 A） 也是Person 的实例。 也就是在 Person 创建的时候，创建了一个它的实例对象并赋值给它的 prototype，基本过程如下： var A = new Person(); Person.prototype = A; 结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。 原型对象其实就是普通对象（但 Function.prototype 除外，它是函数对象，但它很特殊，他没有prototype属性（前面说道函数对象都有prototype属性））。看下面的例子： function Person(){}; console.log(Person.prototype) //Person{} console.log(typeof Person.prototype) //Object console.log(typeof Function.prototype) // Function，这个特殊 console.log(typeof Object.prototype) // Object console.log(typeof Function.prototype.prototype) //undefined Function.prototype 为什么是函数对象呢？ var A = new Function (); Function.prototype = A; 上文提到凡是通过 new Function( ) 产生的对象都是函数对象。因为 A 是函数对象，所以Function.prototype 是函数对象。 那原型对象是用来做什么的呢？主要作用是用于继承。举个例子： var Person = function(name){ this.name = name; // tip: 当函数执行时这个 this 指的是谁？ }; Person.prototype.getName = function(){ return this.name; // tip: 当函数执行时这个 this 指的是谁？ } var person1 = new person(&apos;Mick&apos;); person1.getName(); //Mick 从这个例子可以看出，通过给 Person.prototype 设置了一个函数对象的属性，那有 Person 的实例（person1）出来的普通对象就继承了这个属性。具体是怎么实现的继承，就要讲到下面的原型链了。 小问题，上面两个 this 都指向谁？ var person1 = new person(&apos;Mick&apos;); person1.name = &apos;Mick&apos;; // 此时 person1 已经有 name 这个属性了 person1.getName(); //Mick 故两次 this 在函数执行时都指向 person1。 四. proto JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做proto 的内置属性，用于指向创建它的构造函数的原型对象。 对象 person1 有一个 proto属性，创建它的构造函数是 Person，构造函数的原型对象是 Person.prototype ，所以： person1.proto == Person.prototype 请看下图： 《JavaScript 高级程序设计》的图 6-1 根据上面这个连接图，我们能得到： Person.prototype.constructor == Person; person1.__proto__ == Person.prototype; person1.constructor == Person; 不过，要明确的真正重要的一点就是，这个连接存在于实例（person1）与构造函数（Person）的原型对象（Person.prototype）之间，而不是存在于实例（person1）与构造函数（Person）之间。 注意：因为绝大部分浏览器都支持proto属性，所以它才被加入了 ES6 里（ES5 部分浏览器也支持，但还不是标准）。 五. 构造器 熟悉 Javascript 的童鞋都知道，我们可以这样创建一个对象： var obj = {} 它等同于下面这样： var obj = new Object() obj 是构造函数（Object）的一个实例。所以： obj.constructor === Object obj.proto === Object.prototype 新对象 obj 是使用 new 操作符后跟一个构造函数来创建的。构造函数（Object）本身就是一个函数（就是上面说的函数对象），它和上面的构造函数 Person 差不多。只不过该函数是出于创建新对象的目的而定义的。所以不要被 Object 吓倒。 同理，可以创建对象的构造器不仅仅有 Object，也可以是 Array，Date，Function等。 所以我们也可以构造函数来创建 Array、 Date、Function var b = new Array(); b.constructor === Array; b.__proto__ === Array.prototype; var c = new Date(); c.constructor === Date; c.__proto__ === Date.prototype; var d = new Function(); d.constructor === Function; d.__proto__ === Function.prototype; 这些构造器都是函数对象： 函数对象 六. 原型链 小测试来检验一下你理解的怎么样： person1.proto 是什么？ Person.proto 是什么？ Person.prototype.proto 是什么？ Object.proto 是什么？ Object.prototypeproto 是什么？ 答案： 第一题： 因为 person1.proto === person1[的构造函数].prototype 因为 person1[的构造函数] === Person 所以 person1.proto === Person.prototype 第二题： 因为 Person.proto === person1[的构造函数].prototype 因为 Person[的构造函数] === Function 所以 Person.proto === Function.prototype 第三题： 因为 Person.prototypeproto === Person.prototype[的构造函数].prototype 因为 Person.prototype[的构造函数] === Object 所以 Person.proto === Object.prototype 第四题，参照第二题，因为 Person 和 Object 一样都是构造函数 第五题： Object.prototype 对象也有proto属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端。 Object.prototype.proto === null 七. 函数对象 （复习一下前面的知识点） 所有函数对象的proto都指向Function.prototype，它是一个空函数（Empty function） Number.__proto__ === Function.prototype // true Number.constructor == Function //true Boolean.__proto__ === Function.prototype // true Boolean.constructor == Function //true String.__proto__ === Function.prototype // true String.constructor == Function //true // 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身 Object.__proto__ === Function.prototype // true Object.constructor == Function // true // 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身 Function.__proto__ === Function.prototype // true Function.constructor == Function //true Array.__proto__ === Function.prototype // true Array.constructor == Function //true RegExp.__proto__ === Function.prototype // true RegExp.constructor == Function //true Error.__proto__ === Function.prototype // true Error.constructor == Function //true Date.__proto__ === Function.prototype // true Date.constructor == Function //true JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的proto是Object.prototype。如下 Math.__proto__ === Object.prototype // true Math.construrctor == Object // true JSON.__proto__ === Object.prototype // true JSON.construrctor == Object //true 上面说的函数对象当然包括自定义的。如下 // 函数声明 function Person() {} // 函数表达式 var Perosn = function() {} console.log(Person.__proto__ === Function.prototype) // true console.log(Man.__proto__ === Function.prototype) // true 这说明什么呢？ 所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind （你应该明白第一句话，第二句话我们下一节继续说，先挖个坑：）） Function.prototype也是唯一一个typeof XXX.prototype为 function的prototype。其它的构造器的prototype都是一个对象（原因第三节里已经解释过了）。如下（又复习了一遍）： console.log(typeof Function.prototype) // function console.log(typeof Object.prototype) // object console.log(typeof Number.prototype) // object console.log(typeof Boolean.prototype) // object console.log(typeof String.prototype) // object console.log(typeof Array.prototype) // object console.log(typeof RegExp.prototype) // object console.log(typeof Error.prototype) // object console.log(typeof Date.prototype) // object console.log(typeof Object.prototype) // object 噢，上面还提到它是一个空的函数，console.log(Function.prototype) 下看看（留意，下一节会再说一下这个） 知道了所有构造器（含内置及自定义）的proto都是Function.prototype，那Function.prototype的proto是谁呢？ 相信都听说过JavaScript中函数也是一等公民，那从哪能体现呢？如下 console.log(Function.prototype.proto === Object.prototype) // true 这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。（你也应该明白第一句话，第二句话我们下一节继续说，不用挖坑了，还是刚才那个坑；）） 最后Object.prototype的proto是谁？ Object.prototype.proto === null // true 已经到顶了，为null。(读到现在，再回过头看第五章，能明白吗？) 八. Prototype 在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 prototype 属性了。对于 ECMAScript 中的引用类型而言，prototype 是保存着它们所有实例方法的真正所在。换句话所说，诸如 toString()和 valuseOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。 ——《JavaScript 高级程序设计》第三版 P116 我们知道 JS 内置了一些方法供我们使用，比如： 对象可以用 constructor/toString()/valueOf() 等方法; 数组可以用 map()/filter()/reducer() 等方法； 数字可用用 parseInt()/parseFloat()等方法； Why ？？？ why?? 当我们创建一个函数时： var Person = new Object() Person 是 Object 的实例，所以 Person 继承了Object 的原型对象Object.prototype上所有的方法： Object.prototype Object 的每个实例都具有以上的属性和方法。 所以我可以用 Person.constructor 也可以用 Person.hasOwnProperty。 当我们创建一个数组时： var num = new Array() num 是 Array 的实例，所以 num 继承了Array 的原型对象Array.prototype上所有的方法： Array.prototype Are you f*ing kidding me? 这尼玛怎么是一个空数组？？？ doge 我们可以用一个 ES5 提供的新方法：Object.getOwnPropertyNames 获取所有（包括不可枚举的属性）的属性名不包括 prototy 中的属性，返回一个数组： var arrayAllKeys = Array.prototype; // [] 空数组 // 只得到 arrayAllKeys 这个对象里所有的属性名(不会去找 arrayAllKeys.prototype 中的属性) console.log(Object.getOwnPropertyNames(arrayAllKeys)); /* 输出： [&quot;length&quot;, &quot;constructor&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;join&quot;, &quot;pop&quot;, &quot;push&quot;, &quot;concat&quot;, &quot;reverse&quot;, &quot;shift&quot;, &quot;unshift&quot;, &quot;slice&quot;, &quot;splice&quot;, &quot;sort&quot;, &quot;filter&quot;, &quot;forEach&quot;, &quot;some&quot;, &quot;every&quot;, &quot;map&quot;, &quot;indexOf&quot;, &quot;lastIndexOf&quot;, &quot;reduce&quot;, &quot;reduceRight&quot;, &quot;entries&quot;, &quot;keys&quot;, &quot;copyWithin&quot;, &quot;find&quot;, &quot;findIndex&quot;, &quot;fill&quot;] */ 这样你就明白了随便声明一个数组，它为啥能用那么多方法了。 细心的你肯定发现了Object.getOwnPropertyNames(arrayAllKeys) 输出的数组里并没有 constructor/hasOwnPrototype等对象的方法（你肯定没发现）。 但是随便定义的数组也能用这些方法 var num = [1]; console.log(num.hasOwnPrototype()) // false (输出布尔值而不是报错) Why ？？？ why?? 因为Array.prototype 虽然没这些方法，但是它有原型对象（proto）： // 上面我们说了 Object.prototype 就是一个普通对象。 Array.prototype.__proto__ == Object.prototype 所以 Array.prototype 继承了对象的所有方法，当你用num.hasOwnPrototype()时，JS 会先查一下它的构造函数 （Array） 的原型对象 Array.prototype 有没有有hasOwnPrototype()方法，没查到的话继续查一下 Array.prototype 的原型对象 Array.prototype.proto有没有这个方法。 当我们创建一个函数时： var f = new Function(&quot;x&quot;,&quot;return x*x;&quot;); //当然你也可以这么创建 f = function(x){ return x*x } console.log(f.arguments) // arguments 方法从哪里来的？ console.log(f.call(window)) // call 方法从哪里来的？ console.log(Function.prototype) // function() {} （一个空的函数） console.log(Object.getOwnPropertyNames(Function.prototype)); /* 输出 [&quot;length&quot;, &quot;name&quot;, &quot;arguments&quot;, &quot;caller&quot;, &quot;constructor&quot;, &quot;bind&quot;, &quot;toString&quot;, &quot;call&quot;, &quot;apply&quot;] */ 我们再复习第八小节这句话： 所有函数对象proto都指向 Function.prototype，它是一个空函数（Empty function） 嗯，我们验证了它就是空函数。不过不要忽略前半句。我们枚举出了它的所有的方法，所以所有的函数对象都能用，比如: 函数对象 如果你还没搞懂啥是函数对象？ 去屎 | center 还有，我建议你可以再复习下为什么： Function.prototype 是唯一一个typeof XXX.prototype为 “function”的prototype 我猜你肯定忘了。 九. 复习一下 第八小节我们总结了： 所有函数对象的 __proto__ 都指向 Function.prototype，它是一个空函数（Empty function） 但是你可别忘了在第三小节我们总结的： 所有对象的 __proto__ 都指向其构造器的 prototype 咦，我找了半天怎么没找到这句话…… doge | center 我们下面再复习下这句话。 先看看 JS 内置构造器： var obj = {name: &apos;jack&apos;} var arr = [1,2,3] var reg = /hello/g var date = new Date var err = new Error(&apos;exception&apos;) console.log(obj.__proto__ === Object.prototype) // true console.log(arr.__proto__ === Array.prototype) // true console.log(reg.__proto__ === RegExp.prototype) // true console.log(date.__proto__ === Date.prototype) // true console.log(err.__proto__ === Error.prototype) // true 再看看自定义的构造器，这里定义了一个 Person： function Person(name) { this.name = name; } var p = new Person(&apos;jack&apos;) console.log(p.__proto__ === Person.prototype) // true p 是 Person 的实例对象，p 的内部原型总是指向其构造器 Person 的原型对象 prototype。 每个对象都有一个 constructor 属性，可以获取它的构造器，因此以下打印结果也是恒等的： function Person(name) { this.name = name } var p = new Person(&apos;jack&apos;) console.log(p.__proto__ === p.constructor.prototype) // true 上面的Person没有给其原型添加属性或方法，这里给其原型添加一个getName方法： function Person(name) { this.name = name } // 修改原型 Person.prototype.getName = function() {} var p = new Person(&apos;jack&apos;) console.log(p.__proto__ === Person.prototype) // true console.log(p.__proto__ === p.constructor.prototype) // true 可以看到p.proto与Person.prototype，p.constructor.prototype都是恒等的，即都指向同一个对象。 如果换一种方式设置原型，结果就有些不同了： function Person(name) { this.name = name } // 重写原型 Person.prototype = { getName: function() {} } var p = new Person(&apos;jack&apos;) console.log(p.__proto__ === Person.prototype) // true console.log(p.__proto__ === p.constructor.prototype) // false 这里直接重写了 Person.prototype（注意：上一个示例是修改原型）。输出结果可以看出p.proto仍然指向的是Person.prototype，而不是p.constructor.prototype。 这也很好理解，给Person.prototype赋值的是一个对象直接量{getName: function(){}}，使用对象直接量方式定义的对象其构造器（constructor）指向的是根构造器Object，Object.prototype是一个空对象{}，{}自然与{getName: function(){}}不等。如下： var p = {} console.log(Object.prototype) // 为一个空的对象{} console.log(p.constructor === Object) // 对象直接量方式定义的对象其constructor为Object console.log(p.constructor.prototype === Object.prototype) // 为true，不解释(๑ˇ3ˇ๑) 十. 原型链（再复习一下：） 下面这个例子你应该能明白了！ function Person(){} var person1 = new Person(); console.log(person1.__proto__ === Person.prototype); // true console.log(Person.prototype.__proto__ === Object.prototype) //true console.log(Object.prototype.__proto__) //null Person.__proto__ == Function.prototype; //true console.log(Function.prototype)// function(){} (空函数) var num = new Array() console.log(num.__proto__ == Array.prototype) // true console.log( Array.prototype.__proto__ == Object.prototype) // true console.log(Array.prototype) // [] (空数组) console.log(Object.prototype.__proto__) //null console.log(Array.__proto__ == Function.prototype)// true 疑点解惑： Object.proto === Function.prototype // trueObject 是函数对象，是通过new Function()创建的，所以Object.proto指向Function.prototype。（参照第八小节：「所有函数对象的proto都指向Function.prototype」） Function.proto === Function.prototype // trueFunction 也是对象函数，也是通过new Function()创建，所以Function.proto指向Function.prototype。自己是由自己创建的，好像不符合逻辑，但仔细想想，现实世界也有些类似，你是怎么来的，你妈生的，你妈怎么来的，你姥姥生的，……类人猿进化来的，那类人猿从哪来，一直追溯下去……，就是无，（NULL生万物）正如《道德经》里所说“无，名天地之始”。 Function.prototype.proto === Object.prototype //true其实这一点我也有点困惑，不过也可以试着解释一下。Function.prototype是个函数对象，理论上他的proto应该指向 Function.prototype，就是他自己，自己指向自己，没有意义。JS一直强调万物皆对象，函数对象也是对象，给他认个祖宗，指向Object.prototype。Object.prototype.proto === null，保证原型链能够正常结束。 十一 总结 原型和原型链是JS实现继承的一种模型。 原型链的形成是真正是靠proto 而非prototype 要深入理解这句话，我们再举个例子，看看前面你真的理解了吗？ var animal = function(){}; var dog = function(){}; animal.price = 2000; dog.prototype = animal; var tidy = new dog(); console.log(dog.price) //undefined console.log(tidy.price) // 2000 这里解释一下： var dog = function(){}; dog.prototype.price = 2000; var tidy = new dog(); console.log(tidy.price); // 2000 console.log(dog.price); //undefined var dog = function(){}; var tidy = new dog(); tidy.price = 2000; console.log(dog.price); //undefined 这个明白吧？想一想我们上面说过这句话： 实例（tidy）和 原型对象（dog.prototype）存在一个连接。不过，要明确的真正重要的一点就是，这个连接存在于实例（tidy）与构造函数的原型对象（dog.prototype）之间，而不是存在于实例（tidy）与构造函数（dog）之间。 聪明的你肯定想通了吧 ：）","categories":[],"tags":[]}]}