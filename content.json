{"meta":{"title":"wangleah","subtitle":"不要因为别人的光芒，而忘了自己想走的路!","description":null,"author":"wangleah","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"mongodb安装、配置及操作命令","slug":"前端工具/mongodb安装及相关配置","date":"2017-03-09T16:00:00.000Z","updated":"2017-03-12T12:43:05.664Z","comments":true,"path":"2017/03/10/前端工具/mongodb安装及相关配置/","link":"","permalink":"http://yoursite.com/2017/03/10/前端工具/mongodb安装及相关配置/","excerpt":"为了更好的学习 MongoDB 数据库，大家可以参考菜鸟教程上的 MongoDB 数据库教程文档，链接地址：http://www.runoob.com/mongodb/mongodb-tutorial.html mongodb数据库官网：https://www.mongodb.com/ 第一步 安装步骤1.先进入网址，点击”download” （网址：https://www.mongodb.com/）","text":"为了更好的学习 MongoDB 数据库，大家可以参考菜鸟教程上的 MongoDB 数据库教程文档，链接地址：http://www.runoob.com/mongodb/mongodb-tutorial.html mongodb数据库官网：https://www.mongodb.com/ 第一步 安装步骤1.先进入网址，点击”download” （网址：https://www.mongodb.com/） 2.点击进行下载，下载zip或者version里面的(安装在C盘或者D盘，最好是安装路径是默认的) 3.检验是不是安装成功 1在cmd终端中输入： mongo --version 或是 mongod --version ,能看到版本好,说明安装成功 第二步 MongoDB配置启动服务器1、创建数据目录 将数据目录放在根目录下(如：c:\\或者D:\\等)，数据目录的命名随意，最好叫 data; 在data文件中建立文件夹 db和log 然后启动执行mongod.exe --dbpath c:\\data 如果启动成功就ok了 2、配置全局启动mongodb（开机直接启动） 首先在data/log文件夹下建立mongodb.log文件 然后打开cmd终端输入 1mongod.exe --bind_ip 127.0.0.1 --logpath &quot;C:/data/log/mongodb.log&quot; --logappend --dbpath &quot;c:/datas&quot; --port 27017 --serviceName &quot;MongoDBServer&quot; --serviceDisplayName &quot;MongoDBServerDisplayName&quot; --install 然后重新打开cmd终端 输入services.msc 可以看到服务界面，启动服务即可 然后这样电脑就自动开启了mongod服务 3、启动连接mongodb服务器 在终端输入 mongo 或者 mongo --host 127.0.0.1 --port 27017 1234567891011如果看到类似于如下的字样说明连接成功： MongoDB shell version v3.4.2 connecting to: mongodb://127.0.0.1:27017 MongoDB server version: 3.4.2 Server has startup warnings: 2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten] 2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database. 2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted. 2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten] &gt; 基本操作命令也可以使用图形化界面robomongo1234可以参考: http://www.yiibai.com/mongodb/mongodb_create_collection.html http://www.runoob.com/mongodb/mongodb-tutorial.html show dbs 查看当前服务实例上所有的数据库 use 数据库名称 如果数据库不存在，则创建数据库，否则切换到指定数据库。 db.dropDatabase() 删除数据库,注意,要在切换的数据库中删除 db 查看当前所处的数据库 show collections 查看当前数据库中所有的集合 db.createCollection(&quot;集合名称&quot;) 创建集合 db.集合名称.drop() 删除集合 db.集合名称.insert({数据文档}) 插入的每一条文档会自动帮我们生成一个_id字段,它是mongodb自动维护的,不需要我们关心 db.集合名称.find() 查询指定集合中所有的数据 可以通过 db.集合名称.find().pretty() 美化输出格式 默认是查询所有，可以通过：db.集合名称.find({查询条件}) 按条件查询集合中的数据 模糊查询的条件 {要查询的字段:{$regex: ‘关键字’}} db.集合名称.update({更新条件}, {要更新的字段}) 更新指定集合数据,注意点,要更新的字段一定要这样写 {$set:{字段的名称:字段的值}}, db.集合名称.remove({删除条件}) 删除指定集合中的数据 exit 退出当前操作 cls 清屏 注意点:更新和删除时一般都需要带条件,除非是全部更新与全部删除,不过全部更新与全部删除这样很危险,实际操作过程中很少","categories":[],"tags":[]},{"title":"JavaScript API 合集","slug":"javascript/JavaScript API","date":"2017-01-05T12:57:30.000Z","updated":"2017-04-06T02:57:39.925Z","comments":true,"path":"2017/01/05/javascript/JavaScript API/","link":"","permalink":"http://yoursite.com/2017/01/05/javascript/JavaScript API/","excerpt":"今天在掘金上看到大神写的这篇文章，感觉挺不错的，收集下来，方便以后进行查阅","text":"今天在掘金上看到大神写的这篇文章，感觉挺不错的，收集下来，方便以后进行查阅 一、节点 1.1 节点属性 1234567891011121314151617181920Node.nodeName //返回节点名称，只读Node.nodeType //返回节点类型的常数值，只读Node.nodeValue //返回Text或Comment节点的文本值，只读Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写Node.baseURI //返回当前网页的绝对路径Node.ownerDocument //返回当前节点所在的顶层文档对象，即documentNode.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点Node.parentNode //返回当前节点的父节点Node.parentElement //返回当前节点的父Element节点Node.childNodes //返回当前节点的所有子节点Node.firstChild //返回当前节点的第一个子节点Node.lastChild //返回当前节点的最后一个子节点//parentNode接口Node.children //返回指定节点的所有Element子节点Node.firstElementChild //返回当前节点的第一个Element子节点Node.lastElementChild //返回当前节点的最后一个Element子节点Node.childElementCount //返回当前节点所有Element子节点的数目。 1.2 操作 12345678910111213141516Node.appendChild(node) //向节点添加最后一个子节点Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点Node.cloneNode(true); // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)Node.insertBefore(newNode,oldNode) // 在指定子节点之前插入新的子节点Node.removeChild(node) //删除节点，在要删除节点的父节点上操作Node.replaceChild(newChild,oldChild) //替换节点Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点。Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系Node.isEqualNode(noe) //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。//ChildNode接口Node.remove() //用于删除当前节点Node.before() //Node.after()Node.replaceWith() 1.3 Document节点 1.3.1 Document节点的属性 12345678910111213141516171819202122232425262728document.doctype //document.documentElement //返回当前文档的根节点document.defaultView //返回document对象所在的window对象document.body //返回当前文档的&lt;body&gt;节点document.head //返回当前文档的&lt;head&gt;节点document.activeElement //返回当前文档中获得焦点的那个元素。//节点集合属性document.links //返回当前文档的所有a元素document.forms //返回页面中所有表单元素document.images //返回页面中所有图片元素document.embeds //返回网页中所有嵌入对象document.scripts //返回当前文档的所有脚本document.styleSheets //返回当前网页的所有样式表//文档信息属性document.documentURI //表示当前文档的网址document.URL //返回当前文档的网址document.domain //返回当前文档的域名document.lastModified //返回当前文档最后修改的时间戳document.location //返回location对象，提供当前文档的URL信息document.referrer //返回当前文档的访问来源document.title //返回当前文档的标题document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。document.readyState //返回当前文档的状态document.designMode //控制当前文档是否可编辑，可读写document.compatMode //返回浏览器处理文档的模式document.cookie //用来操作Cookie 1.3.2 Document节点的方法 （1）读写方法 1234document.open() //用于新建并打开一个文档document.close() //不安比open方法所新建的文档document.write() //用于向当前文档写入内容document.writeIn() //用于向当前文档写入内容，尾部添加换行符。 （2）查找节点 1234567document.querySelector(selectors) //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。document.querySelectorAll(selectors) //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素document.getElementsByName(name) //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）document.getElementById(id) //返回匹配指定id属性的元素节点。document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点。 （3）生成节点 1234document.createElement(tagName) //用来生成HTML元素节点。document.createTextNode(text) //用来生成文本节点document.createAttribute(name) //生成一个新的属性对象节点，并返回它。document.createDocumentFragment() //生成一个DocumentFragment对象 （4）事件方法 1234document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用document.addEventListener(type,listener,capture) //注册事件document.removeEventListener(type,listener,capture) //注销事件document.dispatchEvent(event) //触发事件 （5）其他 123document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。document.importNode(externalNode, deep) //从外部文档拷贝指定节点，插入当前文档。 1.4 Element节点 1.4.1 Element节点的属性 （1）特性属性 12345678Element.attributes //返回当前元素节点的所有属性节点Element.id //返回指定元素的id属性，可读写Element.tagName //返回指定元素的大写标签名Element.innerHTML //返回该元素包含的HTML代码，可读写Element.outerHTML //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写Element.className //返回当前元素的class属性，可读写Element.classList //返回当前元素节点的所有class集合Element.dataset //返回元素节点中所有的data-*属性。 （2）尺寸属性 12345678910111213Element.clientHeight //返回元素节点可见部分的高度Element.clientWidth //返回元素节点可见部分的宽度Element.clientLeft //返回元素节点左边框的宽度Element.clientTop //返回元素节点顶部边框的宽度Element.scrollHeight //返回元素节点的总高度Element.scrollWidth //返回元素节点的总宽度Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值Element.offsetHeight //返回元素的垂直高度(包含border,padding)Element.offsetWidth //返回元素的水平宽度(包含border,padding)Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移Element.offsetTop //返回水平位移Element.style //返回元素节点的行内样式 （3）节点相关属性 1234567Element.children //包括当前元素节点的所有子元素Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数Element.firstElementChild //返回当前节点的第一个Element子节点 Element.lastElementChild //返回当前节点的最后一个Element子节点 Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML节点Element.offsetParent //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。 1.4.2 Element节点的方法 （1）位置方法 1234567891011121314151617getBoundingClientRect() // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高// top 元素上外边界距窗口最上面的距离// right 元素右外边界距窗口最上面的距离// bottom 元素下外边界距窗口最上面的距离// left 元素左外边界距窗口最上面的距离// width 元素自身宽(包含border,padding) // height 元素自身高(包含border,padding) getClientRects() //返回当前元素在页面上形参的所有矩形。// 元素在页面上的偏移量 var rect = el.getBoundingClientRect() return &#123; top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft &#125; （2）属性方法 1234Element.getAttribute()：读取指定属性 Element.setAttribute()：设置指定属性 Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性 Element.removeAttribute()：移除指定属性 （3）查找方法 1234Element.querySelector() Element.querySelectorAll() Element.getElementsByTagName() Element.getElementsByClassName() （4）事件方法 1234567891011121314151617181920Element.addEventListener()：添加事件的回调函数 Element.removeEventListener()：移除事件监听函数 Element.dispatchEvent()：触发事件//ie8Element.attachEvent(oneventName,listener)Element.detachEvent(oneventName,listener)// event对象 var event = window.event||event; // 事件的目标节点 var target = event.target || event.srcElement;// 事件代理 ul.addEventListener('click', function(event) &#123; if (event.target.tagName.toLowerCase() === 'li') &#123; console.log(event.target.innerHTML) &#125; &#125;); （5）其他 1234567891011Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。Element.insertAdjacentHTML(where, htmlString); Element.insertAdjacentHTML('beforeBegin', htmlString); // 在该元素前插入 Element.insertAdjacentHTML('afterBegin', htmlString); // 在该元素第一个子元素前插入 Element.insertAdjacentHTML('beforeEnd', htmlString); // 在该元素最后一个子元素后面插入 Element.insertAdjacentHTML('afterEnd', htmlString); // 在该元素后插入Element.remove() //用于将当前元素节点从DOM中移除Element.focus() //用于将当前页面的焦点，转移到指定元素上 二、CSS操作 （1）类名操作 12345678910111213141516171819//ie8以下Element.className //获取元素节点的类名Element.className += ' ' + newClassName //新增一个类名//判断是否有某个类名function hasClass(element,className)&#123; return new RegExp(className,'gi').test(element.className);&#125;//移除classfunction removeClass(element,className)&#123; element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'),'');&#125;//ie10 element.classList.add(className) //新增element.classList.remove(className) //删除element.classList.contains(className) //是否包含element.classList.toggle(className) //toggle class （2）style操作 1234567891011121314151617element.setAttribute('style','')element.style.backgroundColor = 'red'element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value) //设置css属性element.style.getPropertyValue(property) //获取css属性element.style.removeProperty(property) //删除css属性操作非内联样式//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,':after')[attrName] 三、对象 3.1 Object对象 （1）生成实例对象 1var o = new Object() （2）属性 1Object.prototype //返回原型对象 （3）方法 12Object.keys(o) //遍历对象的可枚举属性Object.getOwnPropertyName(o) //遍历对象不可枚举的属性 对象实例的方法 123456valueOf()：返回当前对象对应的值。 toString()：返回当前对象对应的字符串形式。 toLocaleString()：返回当前对象对应的本地字符串形式。 hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 isPrototypeOf()：判断当前对象是否为另一个对象的原型。propertyIsEnumerable()：判断某个属性是否可枚举。 3.2 Array对象 （1）生成实例对象 1var a = new Array() （2）属性 1a.length //长度 （3）Array.isArray() 1Array.isArray(a) //用来判断一个值是否为数组 （4）Array实例的方法 12345678910111213141516171819202122a.valueof() //返回数组本身a.toString() //返回数组的字符串形式a.push(value,vlaue....) //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。pop() //用于删除数组的最后一个元素，并返回该元素join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat() //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。shift() //用于删除数组的第一个元素，并返回该元素。unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。reverse() //用于颠倒数组中元素的顺序，返回改变后的数组slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort() //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。map(elem,index,arr) //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf() //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 3.3 Number对象 （1）生成对象 1var n = new Number() （2）Number对象的属性 1234567Number.POSITIVE_INFINITY：正的无限，指向Infinity。 Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。 Number.NaN：表示非数值，指向NaN。 Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。 Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。 Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。 Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 （4）Number对象实例的方法 1234toString() //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。toFixed() //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。toExponential() //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。toPrecision() //用于将一个数转为指定位数的有效数字。 3.4 String 对象 （1）生成实例对象 1var s = new String() （2）String对象的属性 1s.length //返回字符串的长度 （3）方法 1234567891011121314151617s.chatAt(index) //返回指定位置的字符s.fromCharCode() //该方法的参数是一系列Unicode码点，返回对应的字符串。s.charCodeAt(index) //返回给定位置字符的Unicode码点（十进制表示）s.concat(s2) //用于连接两个字符串s.slice(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim() //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase() //全部转为大写s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 3.5 Math对象 （1）属性 12345678Math.E：常数e。 Math.LN2：2的自然对数。 Math.LN10：10的自然对数。 Math.LOG2E：以2为底的e的对数。 Math.LOG10E：以10为底的e的对数。 Math.PI：常数Pi。 Math.SQRT1_2：0.5的平方根。 Math.SQRT2：2的平方根。 （2）数学方法 1234567891011Math.abs()：返回参数的绝对值 Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整 Math.max(n,n1,...)：可接受多个参数，返回最大值 Math.min(n,n1,..)：可接受多个参数，返回最小值 Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。 Math.log()：返回以e为底的自然对数值。Math.exp()：返回e的指数，也就是常数e的参数次方。Math.round()：四舍五入 Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 （3）三角函数方法 123456Math.sin()：返回参数的正弦 Math.cos()：返回参数的余弦 Math.tan()：返回参数的正切 Math.asin()：返回参数的反正弦（弧度值） Math.acos()：返回参数的反余弦（弧度值） Math.atan()：返回参数的反正切（弧度值） 3.6 JSON对象 （1）方法 123456JSON.stringify() //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。JSON.parse() //用于将JSON字符串转化成对象。 3.7 console对象 （1）方法 1234567891011121314151617181920212223242526console.log(text,text2,...) //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。console.info() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.debug() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.warn() //输出信息时，在最前面加一个黄色三角，表示警告；console.error() //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈console.table() //可以将复合类型的数据转为表格显示。console.count() //用于计数，输出它被调用了多少次。console.dir() //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。console.dirxml() //用于以目录树的形式，显示DOM节点。console.assert() //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。//这两个方法用于计时，可以算出一个操作所花费的准确时间。console.time()console.timeEnd()//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。console.profile() //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。console.profileEnd() //用来结束正在运行的性能测试器。console.group()console.groupend()//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。console.groupCollapsed() //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。console.trace() //显示当前执行的代码在堆栈中的调用路径。console.clear() //用于清除当前控制台的所有输出，将光标回置到第一行。","categories":[],"tags":[]},{"title":"原生JS在IE中的兼容性","slug":"javascript/原生JS在IE中的兼容性","date":"2016-09-14T16:00:00.000Z","updated":"2017-03-29T06:58:08.332Z","comments":true,"path":"2016/09/15/javascript/原生JS在IE中的兼容性/","link":"","permalink":"http://yoursite.com/2016/09/15/javascript/原生JS在IE中的兼容性/","excerpt":"","text":"获取某个元素(标签)的文本内容1234567891011121314/** * 获取某个元素(标签)的文本内容 * @param element -----&gt;文本的元素(标签) * @returns &#123;*&#125;----&gt;返回值是文本的内容 */function getInnerText(element) &#123; if (typeof(element.textContent) == \"undefined\") &#123; //IE8 return element.innerText = txt; &#125; else &#123; //谷歌或者火狐 return element.textContent = txt; &#125;&#125; 为元素添加多个事件1234567891011121314151617/** * 为元素添加多个事件---兼容代码 谷歌 火狐 IE8都支持 * 任意的元素,任意的事件,事件对应事件处理函数 * @param element----元素 * @param type---事件类型 * @param fn---事件处理函数 *//*此代码这是判断浏览器是否兼容，而不是用了哪种方法*/function addEventListener(element, type, fn) &#123; if (element.addEventListener) &#123; element.addEventListener(type, fn, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + type, fn); &#125; else &#123; element[\"on\" + type] = fn; &#125;&#125; 移除事件1234567891011121314151617/** * 移除事件---------兼容代码 谷歌 火狐 IE8都支持 * 为任意的元素移除任意的事件,事件对应着事件处理函数 * @param element----元素 * @param type---事件类型 * @param fn----事件处理函数 *//*此代码这是判断浏览器是否兼容，而不是用了哪种方法*/function removeListener(element, type, fn) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, fn, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(\"on\" + type, fn); &#125; else &#123; element[\"on\" + type] = null; &#125;&#125; 阻止冒泡123456789101112/** * 阻止事件冒泡 * @param e */function cancelBubble(e) &#123; e = e || window.event; if (e.stopPropagation) &#123; e.stopPropagation(); &#125; else &#123; e.cancelBubble = true; &#125;&#125; 获取任意元素中的任务属性123456789/** * 获取任意元素中的任务属性 * @param element--&gt;获取的元素 * @param attr----&gt;属性 * @returns &#123;*&#125;---返回值是一个String（字符串） */function getStyle(element, attr) &#123; return element.currentStyle ? element.currentStyle[attr] : window.getComputedStyle(element, null)[attr] || 0;&#125;","categories":[],"tags":[]},{"title":"JavaScript 代码收集","slug":"javascript/常用代码收集","date":"2016-09-12T08:08:32.000Z","updated":"2017-04-06T02:55:50.415Z","comments":true,"path":"2016/09/12/javascript/常用代码收集/","link":"","permalink":"http://yoursite.com/2016/09/12/javascript/常用代码收集/","excerpt":"以下是常用的代码收集，没有任何技术含量，只是填坑的积累。1. PC - js 返回指定范围的随机数(m-n之间)的公式 1Math.random()*(n-m)+m","text":"以下是常用的代码收集，没有任何技术含量，只是填坑的积累。1. PC - js 返回指定范围的随机数(m-n之间)的公式 1Math.random()*(n-m)+m 阻止默认事件 return false return false 123456// event.preventDefault()会阻挡预设要发生的事件.// event.stopPropagation()会阻挡发生冒泡事件.// 而return false则是前面两者的事情他都会做：// 他会做event.preventDefault();// 他会做event.stopPropagation();// 停止callback function的执行并且立即return回来 防止被Iframe嵌套 123if(top != self)&#123; location.href = ”about:blank”;&#125; 两种图片lazy加载的方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// @description 准备为图片预加载使用的插件// 使用的图片容器css类名为lazy-load-wrap// 图片真实地址为data-lazy-src// 当lazy-load-wrap容器进入视口，则开始替换容器内所有需要延迟加载的图片路径，并更改容器的加载状态//第一种方法$.fn.compassLazyLoad=function()&#123; var _HEIGHT=window.innerHeight, _lazyLoadWrap=$('.lazy-load-wrap'); var methods=&#123; setOffsetTop:function()&#123; $.each(_lazyLoadWrap,function(i,n)&#123; $(n).attr(&#123; 'top':n.offsetTop-_HEIGHT, 'status':'wait' &#125;); &#125;) &#125;, isShow:function()&#123; var _scrollTop=$(window).scrollTop; //利用image容器判断是否进入视口，而非image本身 $.each(_lazyLoadWrap,function()&#123; var _that=$(this); if (_that.attr('status')==='done') &#123; return; &#125;; if (_that.attr('top')&lt;=_scrollTop) &#123; _that.find('img[data-lazy-src]').each(function(i,n)&#123; n.src=$(n).data('lazy-src'); &#125;); _that.attr('status','done'); &#125;; &#125;) &#125;, scroll:function()&#123; $(window).on('scroll',function()&#123; methods.isShow(); &#125;); &#125;, init:function()&#123; methods.setOffsetTop(); methods.isShow(); methods.scroll(); &#125; &#125;; methods.init();&#125;//第二种方法var exist=(function($)&#123; var timer=null, temp=[].slice.call($('.container')); ret=&#123;&#125;; for(var i=0,len=temp.length-1;i&lt;=len;i++)&#123; ret[i]=temp[i]; &#125; var isExist=function(winTop,winEnd)&#123; for(var i in ret)&#123; console.log(ret); var item=ret[i], eleTop=item.offsetTop, eleEnd=eleTop+item.offsetHeight; if((eleTop&gt;winTop&amp;&amp;eleTop&lt;=winEnd)||(eleEnd&gt;winTop&amp;&amp;eleEnd&lt;=winEnd))&#123; $(item).css('background','none'); new Tab($(item).attr('id'),data).init; delete ret[i]; &#125; &#125; &#125; return &#123; timer:timer; isExist:isExist; &#125;;&#125;)($);//第三种方法Zepto(function ($) &#123; var swiper = new Swiper('.swiper-container', &#123; pagination: '.swiper-pagination', paginationClickable: true, autoplay: 3000, loop: true, autoplayDisableOnInteraction: false &#125;); (function lazyLoad() &#123; var imgs = $(\".lazyLoad\"); var src = ''; $.each(imgs, function (index, item) &#123; src = $(item).attr('data-src'); $(item).attr('src', src); &#125;); &#125;)();&#125;);$(function () &#123; var lazyLoadTimerId = null; /// 智能加载事件 $(window).bind(\"scroll\", function () &#123; clearTimeout(lazyLoadTimerId); lazyLoadTimerId = setTimeout(function () &#123; // 延迟加载所有图片 var isHttp = (location.protocol === \"http:\"); $(\"#ym_images img\").each(function () &#123; var self = $(this); if (self.filter(\":above-the-fold\").length &gt; 0) &#123; var originUrl = self.attr(\"data-original\"); self.attr(\"src\", originUrl); &#125; &#125;); &#125;, 500); &#125;);&#125;); 某年某月的1号为星期几 12var weekday = [\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"];weekday[new Date(2015, 9, 1).getDay()]; //2015年10月1号 2. Mobile - js js 判断IOS, 安卓 12345var u = navigator.userAgent, app = navigator.appVersion;var isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1; //android终端或者uc浏览器var isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端alert('是否是Android：'+isAndroid);alert('是否是iOS：'+isiOS); 3. 微信 weixin UserAgent 判断微信客户端 12345// Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12F70 MicroMessenger/6.1.5 NetType/WIFIfunction isWechat() &#123; var ua = navigator.userAgent.toLowerCase(); return /micromessenger/i.test(ua) || /windows phone/i.test(ua);&#125; JS接口安全域名不填写，分享onMenuShareAppMessage直接会取默认值。 1// 分享onMenuShareAppMessage直接会取默认值 关闭当前页面 1WeixinJSBridge.call('closeWindow'); 支付接口方法调用必须在addevent里边调用 123document.addEventListener('WeixinJSBridgeReady', function onBridgeReady()&#123; that.initOrder();&#125;, false); 支付接口方法调用必须在 123456789101112WeixinJSBridge.invoke('getBrandWCPayRequest', d, function(res)&#123; if(res.err_msg == \"get_brand_wcpay_request:ok\")&#123; // alert(\"支付成功\"); // union.release(d.orderId); resetUrl(); paySuccess('home', d.orderId); &#125; else &#123; cancelOrder(d.orderId); // alert(res.err_msg); &#125; loading.hide();&#125;); 瀑布流无限加载实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// be dependent on jquery &amp; jquery.infinitescroll.min.js// insert this '&lt;div id=\"more\"&gt;&lt;a href=\"api?page=\"&gt;&lt;/a&gt;&lt;/div&gt;' to your page.html(function($)&#123; $(function()&#123; var $container = $('.list-wrap-gd'); function layOutCallBack() &#123; $container.imagesLoaded(function()&#123; $container.masonry(&#123; itemSelector: '.item-bar', gutter: 10 &#125;); &#125;); $container.imagesLoaded().progress( function() &#123; $container.masonry('layout'); &#125;); &#125; layOutCallBack(); $container.infinitescroll(&#123; navSelector : \"#more\", nextSelector : \"#more a\", itemSelector : \".item-bar\", pixelsFromNavToBottom: 300, loading:&#123; img: \"/images/masonry_loading.gif\", msgText: ' ', finishedMsg: \"&lt;em&gt;已经到最后一页&lt;/em&gt;\", finished: function()&#123; $(\"#more\").remove(); $(\"#infscr-loading\").hide(); &#125; &#125;, errorCallback:function()&#123; $(window).unbind('.infscr'); &#125;, pathParse: function (path, nextPage) &#123; var query = \"\"; var keyword=$(\"#search_keyword\").val(); var cat_id=$(\"#cat_id\").val(); var brand_id=$(\"#brand_id\").val(); var country_id = $(\"#country_id\").val(); query = query + \"&amp;namekeyword=\"+keyword; query = query +\"&amp;cat_id=\"+cat_id query = query + \"&amp;brand_id=\" + brand_id; query = query + \"&amp;country_id=\" + country_id; path = [path,query]; return path; &#125; &#125;, function(newElements) &#123; var $newElems = $( newElements ).css(&#123; opacity: 0 &#125;); $newElems.imagesLoaded(function()&#123; $newElems.animate(&#123; opacity: 1 &#125;); $container.masonry( 'appended', $newElems, true ); layOutCallBack(); &#125;); &#125;); &#125;);&#125;)(jQuery); iOS，Safari浏览器，input等表单focus后fixed元素错位问题 123456789101112131415if( /iPhone|iPod|iPad/i.test(navigator.userAgent) ) &#123; $(document).on('focus', 'input, textarea', function() &#123; $('header').css(\"position\", 'absolute'); $('footer').css(\"position\", 'absolute'); &#125;); $(document).on('blur', 'input, textarea', function() &#123; $('header').css(\"position\", 'fixed'); $('footer').css(\"position\", 'fixed'); &#125;);&#125; 得到地理位置 123456789101112function getLocation(callback)&#123; if(navigator.geolocation)&#123; navigator.geolocation.getCurrentPosition( function(p)&#123; callback(p.coords.latitude, p.coords.longitude); &#125;, function(e)&#123; var msg = e.code + \"\\n\" + e.message; &#125; ); &#125;&#125; rem计算适配 12345678910111213(function(doc, win)&#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function()&#123; var clientWidth = docEl.clientWidth; if(!clientWidth) return; docEl.style.fontSize = 20 * (clientWidth / 320) + 'px'; &#125;; if(!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 另外一种rem方案 1234567891011121314151617181920212223242526272829303132var dpr, rem, scale;var docEl = document.documentElement;var fontEl = document.createElement('style');var metaEl = document.querySelector('meta[name=\"viewport\"]');dpr = window.devicePixelRatio || 1;rem = docEl.clientWidth * 2 / 10;scale = 1 / dpr;// 设置viewport，进行缩放，达到高清效果metaEl.setAttribute('content', 'width=' + dpr * docEl.clientWidth + ',initial-scale=' + scale + ',maximum-scale=' + scale + ', minimum-scale=' + scale + ',user-scalable=no');// 设置data-dpr属性，留作的css hack之用docEl.setAttribute('data-dpr', dpr);// 动态写入样式docEl.firstElementChild.appendChild(fontEl);fontEl.innerHTML = 'html&#123;font-size:' + rem + 'px!important;&#125;';// 给js调用的，某一dpr下rem和px之间的转换函数window.rem2px = function(v) &#123; v = parseFloat(v); return v * rem;&#125;;window.px2rem = function(v) &#123; v = parseFloat(v); return v / rem;&#125;;window.dpr = dpr;window.rem = rem; 获取js所在路径 12345678910111213function getJsDir (src) &#123; var script = null; if (src) &#123; script = [].filter.call(document.scripts, function (v) &#123; return v.src.indexOf(src) !== -1; &#125;)[0]; &#125; else &#123; script = document.scripts[document.scripts.length - 1]; &#125; return script ? script.src.substr(0, script.src.lastIndexOf('/')) : script;&#125; 从全局捕获错误 12345678910111213window.onerror = function (errMsg, scriptURI, lineNumber, columnNumber, errorObj) &#123; setTimeout(function () &#123; var rst = &#123; \"错误信息：\": errMsg, \"出错文件：\": scriptURI, \"出错行号：\": lineNumber, \"出错列号：\": columnNumber, \"错误详情：\": errorObj &#125;; alert(JSON.stringify(rst, null, 10)); &#125;);&#125;; 如何通过 js 修改微信浏览器的title? 1234567var $body = $('body');document.title = 'title'; // hack在微信等webview中无法修改document.title的情况 var $iframe = $('&lt;iframe src=\"/favicon.ico\"&gt;&lt;/iframe&gt;').on('load', function()&#123; setTimeout(function()&#123; $iframe.off('load').remove() &#125;, 0) &#125;).appendTo($body) 1. 常用方法 - js 字符串长度截取 1234567891011121314151617181920function cutstr(str, len) &#123; var temp, icount = 0, patrn = /[^\\x00-\\xff]/， strre = \"\"; for (var i = 0; i &lt; str.length; i++) &#123; if (icount &lt; len - 1) &#123; temp = str.substr(i, 1); if (patrn.exec(temp) == null) &#123; icount = icount + 1 &#125; else &#123; icount = icount + 2 &#125; strre += temp &#125; else &#123; break; &#125; &#125; return strre + \"...\"&#125; 替换全部 123String.prototype.replaceAll = function(s1, s2) &#123; return this.replace(new RegExp(s1, \"gm\"), s2)&#125; 清除空格 1234String.prototype.trim = function() &#123; var reExtraSpace = /^\\s*(.*?)\\s+$/; return this.replace(reExtraSpace, \"$1\")&#125; 清除左空格/右空格 12function ltrim(s)&#123; return s.replace( /^(\\s*| *)/, \"\"); &#125; function rtrim(s)&#123; return s.replace( /(\\s*| *)$/, \"\"); &#125; 判断是否以某个字符串开头 123String.prototype.startWith = function (s) &#123; return this.indexOf(s) == 0&#125; 判断是否以某个字符串结束 1234String.prototype.endWith = function (s) &#123; var d = this.length - s.length; return (d &gt;= 0 &amp;&amp; this.lastIndexOf(s) == d)&#125; 转义html标签 123function HtmlEncode(text) &#123; return text.replace(/&amp;/g, '&amp;').replace(/\\\"/g, '\"').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;')&#125; 时间日期格式转换 123456789101112131415161718Date.prototype.Format = function(formatStr) &#123; var str = formatStr; var Week = ['日', '一', '二', '三', '四', '五', '六']; str = str.replace(/yyyy|YYYY/, this.getFullYear()); str = str.replace(/yy|YY/, (this.getYear() % 100) &gt; 9 ? (this.getYear() % 100).toString() : '0' + (this.getYear() % 100)); str = str.replace(/MM/, (this.getMonth() + 1) &gt; 9 ? (this.getMonth() + 1).toString() : '0' + (this.getMonth() + 1)); str = str.replace(/M/g, (this.getMonth() + 1)); str = str.replace(/w|W/g, Week[this.getDay()]); str = str.replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : '0' + this.getDate()); str = str.replace(/d|D/g, this.getDate()); str = str.replace(/hh|HH/, this.getHours() &gt; 9 ? this.getHours().toString() : '0' + this.getHours()); str = str.replace(/h|H/g, this.getHours()); str = str.replace(/mm/, this.getMinutes() &gt; 9 ? this.getMinutes().toString() : '0' + this.getMinutes()); str = str.replace(/m/g, this.getMinutes()); str = str.replace(/ss|SS/, this.getSeconds() &gt; 9 ? this.getSeconds().toString() : '0' + this.getSeconds()); str = str.replace(/s|S/g, this.getSeconds()); return str&#125; 判断是否为数字类型 12345678function isDigit(value) &#123; var patrn = /^[0-9]*$/; if (patrn.exec(value) == null || value == \"\") &#123; return false &#125; else &#123; return true &#125;&#125; 设置cookie值 123456789function setCookie(name, value, Hours) &#123; var d = new Date(); var offset = 8; var utc = d.getTime() + (d.getTimezoneOffset() * 60000); var nd = utc + (3600000 * offset); var exp = new Date(nd); exp.setTime(exp.getTime() + Hours * 60 * 60 * 1000); document.cookie = name + \"=\" + escape(value) + \";path=/;expires=\" + exp.toGMTString() + \";domain=360doc.com;\"&#125; 获取cookie值 12345function getCookie(name) &#123; var arr = document.cookie.match(new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\")); if (arr != null) return unescape(arr[2]); return null&#125; 加载样式文件表 123456789101112function LoadStyle(url) &#123; try &#123; document.createStyleSheet(url) &#125; catch(e) &#123; var cssLink = document.createElement('link'); cssLink.rel = 'stylesheet'; cssLink.type = 'text/css'; cssLink.href = url; var head = document.getElementsByTagName('head')[0]; head.appendChild(cssLink) &#125;&#125; 返回脚本内容 123456789101112131415161718function evalscript(s) &#123; if(s.indexOf('&lt;script') == -1) return s; var p = /&lt;script[^\\&gt;]*?&gt;([^\\x00]*?)&lt;\\/script&gt;/ig; var arr = []; while(arr = p.exec(s)) &#123; var p1 = /&lt;script[^\\&gt;]*?src=\\\"([^\\&gt;]*?)\\\"[^\\&gt;]*?(reload=\\\"1\\\")?(?:charset=\\\"([\\w\\-]+?)\\\")?&gt;&lt;\\/script&gt;/i; var arr1 = []; arr1 = p1.exec(arr[0]); if(arr1) &#123; appendscript(arr1[1], '', arr1[2], arr1[3]); &#125; else &#123; p1 = /&lt;script(.*?)&gt;([^\\x00]+?)&lt;\\/script&gt;/i; arr1 = p1.exec(arr[0]); appendscript('', arr1[2], arr1[1].indexOf('reload=') != -1); &#125; &#125; return s;&#125; 清除脚本内容 123function stripscript(s) &#123; return s.replace(/&lt;script.*?&gt;.*?&lt;\\/script&gt;/ig, '');&#125; 动态加载脚本文件 1234567891011121314151617181920212223242526272829303132function appendscript(src, text, reload, charset) &#123; var id = hash(src + text); if(!reload &amp;&amp; in_array(id, evalscripts)) return; if(reload &amp;&amp; $(id)) &#123; $(id).parentNode.removeChild($(id)); &#125; evalscripts.push(id); var scriptNode = document.createElement(\"script\"); scriptNode.type = \"text/javascript\"; scriptNode.id = id; scriptNode.charset = charset ? charset : (BROWSER.firefox ? document.characterSet : document.charset); try &#123; if(src) &#123; scriptNode.src = src; scriptNode.onloadDone = false; scriptNode.onload = function () &#123; scriptNode.onloadDone = true; JSLOADED[src] = 1; &#125;; scriptNode.onreadystatechange = function () &#123; if((scriptNode.readyState == 'loaded' || scriptNode.readyState == 'complete') &amp;&amp; !scriptNode.onloadDone) &#123; scriptNode.onloadDone = true; JSLOADED[src] = 1; &#125; &#125;; &#125; else if(text)&#123; scriptNode.text = text; &#125; document.getElementsByTagName('head')[0].appendChild(scriptNode); &#125; catch(e) &#123;&#125;&#125; 返回按ID检索的元素对象 123function $(id) &#123; return !id ? null : document.getElementById(id);&#125; 检验URL链接是否有效 12345678910111213141516171819function getUrlState(URL)&#123; var xmlhttp = new ActiveXObject(\"microsoft.xmlhttp\"); xmlhttp.Open(\"GET\",URL, false); try&#123; xmlhttp.Send(); &#125;catch(e)&#123; &#125;finally&#123; var result = xmlhttp.responseText; if(result)&#123; if(xmlhttp.Status==200)&#123; return(true); &#125;else&#123; return(false); &#125; &#125;else&#123; return(false); &#125; &#125;&#125; 获取当前路径 123456var currentPageUrl = \"\";if (typeof this.href === \"undefined\") &#123; currentPageUrl = document.location.toString().toLowerCase();&#125;else &#123; currentPageUrl = this.href.toString().toLowerCase();&#125; 获取页面高度 123456function getPageHeight()&#123; var g = document, a = g.body, f = g.documentElement, d = g.compatMode == \"BackCompat\" ? a : g.documentElement; return Math.max(f.scrollHeight, a.scrollHeight, d.clientHeight);&#125; 获取页面可视宽度 12345function getPageViewWidth()&#123; var d = document, a = d.compatMode == \"BackCompat\" ? d.body: d.documentElement; return a.clientWidth;&#125; 获取页面宽度 12345function getPageWidth()&#123; var g = document, a = g.body, f = g.documentElement, d = g.compatMode == \"BackCompat\"? a: g.documentElement; return Math.max(f.scrollWidth, a.scrollWidth, d.clientWidth);&#125; 随机数时间戳 1234function uniqueId()&#123; var a=Math.random,b=parseInt; return Number(new Date()).toString()+b(10*a())+b(10*a())+b(10*a());&#125; 日期格式化函数 1234567891011121314151617181920Date.prototype.format = function(format)&#123; var o = &#123; \"M+\" : this.getMonth()+1, //month \"d+\" : this.getDate(), //day \"h+\" : this.getHours(), //hour \"m+\" : this.getMinutes(), //minute \"s+\" : this.getSeconds(), //second \"q+\" : Math.floor((this.getMonth()+3)/3), //quarter \"S\" : this.getMilliseconds() //millisecond &#125;; if(/(y+)/.test(format)) format=format.replace(RegExp.$1,(this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); for(var k in o)&#123; if(new RegExp(\"(\"+ k +\")\").test(format)) format = format.replace(RegExp.$1,RegExp.$1.length==1 ? o[k] :(\"00\"+ o[k]).substr((\"\"+ o[k]).length)); &#125; return format;&#125;//调用//new Date().format(\"yyyy-MM-dd hh:mm:ss\"); 返回顶部的通用方法 1234567891011121314151617181920function backTop(btnId) &#123; var btn = document.getElementById(btnId); var d = document.documentElement; var b = document.body; window.onscroll = set; btn.style.display = \"none\"; btn.onclick = function() &#123; btn.style.display = \"none\"; window.onscroll = null; this.timer = setInterval(function() &#123; d.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); b.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); if ((d.scrollTop + b.scrollTop) == 0) clearInterval(btn.timer, window.onscroll = set); &#125;, 10); &#125;; function set() &#123; btn.style.display = (d.scrollTop + b.scrollTop &gt; 100) ? 'block': \"none\" &#125;&#125;;backTop('goTop'); 获得URL中GET参数值 1234567891011121314// 用法：如果地址是 test.htm?t1=1&amp;t2=2&amp;t3=3, 那么能取得：GET[\"t1\"], GET[\"t2\"], GET[\"t3\"]function get_get()&#123; querystr = window.location.href.split(\"?\") if(querystr[1])&#123; GETs = querystr[1].split(\"&amp;\"); GET = []; for(i=0;i&lt;GETs.length;i++)&#123; tmp_arr = GETs.split(\"=\") key=tmp_arr[0] GET[key] = tmp_arr[1] &#125; &#125; return querystr[1];&#125; 数组去重 12345678910String.prototype.unique=function()&#123; var x=this.split(/[\\r\\n]+/); var y=''; for(var i=0;i&lt;x.length;i++)&#123; if(!new RegExp(\"^\"+x.replace(/([^\\w])/ig,\"\\\\$1\")+\"$\",\"igm\").test(y))&#123; y+=x+\"\\r\\n\" &#125; &#125; return y&#125;; 按字典顺序，对每行进行数组排序 12345function SetSort()&#123; var text=K1.value.split(/[\\r\\n]/).sort().join(\"\\r\\n\");//顺序 var test=K1.value.split(/[\\r\\n]/).sort().reverse().join(\"\\r\\n\");//反序 K1.value=K1.value!=text?text:test;&#125; 字符串反序输出 123function IsReverse(text)&#123; return text.split('').reverse().join('');&#125; 金额大写转换函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//格式转换function transform(tranvalue) &#123; try &#123; var i = 1; var dw2 = new Array(\"\", \"万\", \"亿\"); //大单位 var dw1 = new Array(\"拾\", \"佰\", \"仟\"); //小单位 var dw = new Array(\"零\", \"壹\", \"贰\", \"叁\", \"肆\", \"伍\", \"陆\", \"柒\", \"捌\", \"玖\"); //整数部分用 //以下是小写转换成大写显示在合计大写的文本框中 //分离整数与小数 var source = splits(tranvalue); var num = source[0]; var dig = source[1]; //转换整数部分 var k1 = 0; //计小单位 var k2 = 0; //计大单位 var sum = 0; var str = \"\"; var len = source[0].length; //整数的长度 for (i = 1; i &lt;= len; i++) &#123; var n = source[0].charAt(len - i); //取得某个位数上的数字 var bn = 0; if (len - i - 1 &gt;= 0) &#123; bn = source[0].charAt(len - i - 1); //取得某个位数前一位上的数字 &#125; sum = sum + Number(n); if (sum != 0) &#123; str = dw[Number(n)].concat(str); //取得该数字对应的大写数字，并插入到str字符串的前面 if (n == '0') sum = 0; &#125; if (len - i - 1 &gt;= 0) &#123; //在数字范围内 if (k1 != 3) &#123; //加小单位 if (bn != 0) &#123; str = dw1[k1].concat(str); &#125; k1++; &#125; else &#123; //不加小单位，加大单位 k1 = 0; var temp = str.charAt(0); if (temp == \"万\" || temp == \"亿\") //若大单位前没有数字则舍去大单位 str = str.substr(1, str.length - 1); str = dw2[k2].concat(str); sum = 0; &#125; &#125; if (k1 == 3)&#123; //小单位到千则大单位进一 k2++; &#125; &#125; //转换小数部分 var strdig = \"\"; if (dig != \"\") &#123; var n = dig.charAt(0); if (n != 0) &#123; strdig += dw[Number(n)] + \"角\"; //加数字 &#125; var n = dig.charAt(1); if (n != 0) &#123; strdig += dw[Number(n)] + \"分\"; //加数字 &#125; &#125; str += \"元\" + strdig; &#125; catch(e) &#123; return \"0元\"; &#125; return str;&#125;//拆分整数与小数function splits(tranvalue) &#123; var value = new Array('', ''); temp = tranvalue.split(\".\"); for (var i = 0; i &lt; temp.length; i++) &#123; value = temp; &#125; return value;&#125;","categories":[],"tags":[]},{"title":"自动化构建工具Gulp初体验","slug":"前端工具/自动化构建工具Gulp初体验","date":"2016-08-11T16:00:00.000Z","updated":"2017-03-12T12:41:32.381Z","comments":true,"path":"2016/08/12/前端工具/自动化构建工具Gulp初体验/","link":"","permalink":"http://yoursite.com/2016/08/12/前端工具/自动化构建工具Gulp初体验/","excerpt":"自动化构建工具 对于前端开发来说，自动化构建工具非常重要。他能够帮助我们自动完成许多任务，能够极大的提高我们的工作效率。当然，流行的工具比较多，比如grunt，gulp，webpack等，了解不多的同学可能就开始迷茫了，到底应该学习哪一种？其实实际情况上，除了grunt与gulp是存在替换关系，gulp与其他大多数工具都是可以通过插件相互渗透的，比如webpack，在gulp中有gulp-webpack插件能够完成webpack的工作，比如gulp-bower插件能够完成bower的功能。而gulp比grunt效率更高，更简便的IO操作，更少的API，因此我们只需要好好掌握gulp，就足够了，不需要给自己徒增烦恼。","text":"自动化构建工具 对于前端开发来说，自动化构建工具非常重要。他能够帮助我们自动完成许多任务，能够极大的提高我们的工作效率。当然，流行的工具比较多，比如grunt，gulp，webpack等，了解不多的同学可能就开始迷茫了，到底应该学习哪一种？其实实际情况上，除了grunt与gulp是存在替换关系，gulp与其他大多数工具都是可以通过插件相互渗透的，比如webpack，在gulp中有gulp-webpack插件能够完成webpack的工作，比如gulp-bower插件能够完成bower的功能。而gulp比grunt效率更高，更简便的IO操作，更少的API，因此我们只需要好好掌握gulp，就足够了，不需要给自己徒增烦恼。 学前准备 安装nodejs与npm 在nodejs官网找到对应的版本安装即可，新的nodejs已经集成了npm，在命令行中输入一下指令检测nodejs与npm是否已经安装成功，如果你是在window下使用命令行，建议使用git的命令行工具 12345// 输出node版本&gt; node -v// 输出npm版本&gt; npm -v npm是node的包管理工具，用于管理node的相关插件，使用的几个常用的相关指令如下 12345678// 安装插件&gt; [sudo] npm install &lt;name&gt; [-g] [--save-dev]// 卸载插件&gt; [sudo] npm uninstall &lt;name&gt; [-g] [--save-dev]// 更新插件&gt; [sudo] npm update &lt;name&gt; [-g] [--save-dev] 上面的语法中，中括号[]表示可选参数，尖括号&lt;&gt;表示必填参数，他们分别表示的含义如下 [sudo]: 在类unix操作系统下表示允许使用过通过安全的方式使用特殊权限执行后面的指令，比如在mac os x环境下会因为权限问题指令被拒绝就需要使用到它。 : 插件名字，如果是安装gulp-sass，那么指令如下 1&gt; npm install gulp-sass 安装gulp 在安装之前，请确保已经安装了nodejs与npm 12345// 安装gulp&gt; npm install -g gulp// 通过输出版本号检测是否已经安装成功&gt; gulp -v 于是到这里，一切就准备就绪了，是时候来感受一下gulp的魅力了。 为了大家更好的学习gulp，我在我的github上新建了一个项目 learn-gulp，我会把每一步每一个知识点都作为一次提交push到项目中，这样大家就可以通过查看历史版本，循序渐进的学习gulp的配置了。欢迎大家的fork与star。点击文末的阅读原文或者通过下面的项目地址访问 https://github.com/yangbo5207/learn-gulp 我们先通过一个非常简单的例子，了解一下gulp如何将sass文件编译成css的。在动手尝试之前，我们有2个文件需要重点了解一下 package.json package.json作为gulp的配置文件，能够非常方便的管理nodejs的插件，因为一个项目所要依赖的插件很多，因此不可能将所有的插件都放在git中来管理，我们只需要在项目中保存有一个package.json的配置文件，那么就可以通过下面的指令将该配置文件中的所有依赖包下载下来。 1&gt; npm install 在后续的gulp进阶文章中，我会详细的给大家罗列package.json中所有字段的详细功能。另外，由于这个配置文件中仅仅只是一个json，因此我们可以保存我们自己需要的字段，并且通过node读取使用。 gulpfile.js gulpfile.js是gulp项目中的配置文件，通过这个普通的js文件，我们可以定义gulp的行为，所有的gulp任务都将在这个js文件中来配置。如何编写这个js文件将是我们学会使用gulp的关键。 那么，所有的准备工作与基本的概念我们都有一个了解之后呢，我们就可以通过一个简单的例子来感受一下gulp带给我们的便利了。 实例 通过插件gulp-sass，我们可以将sass文件编译为css文件，sass是css的预编译语言，属于能够10分钟掌握的简单语言，但是它却足够强大，它突破css的局限性，让css也能够玩出花来，值得大家去学习掌握。在实际开发中，为了提高开发效率，我们往往都不会直接使用css，而是通过编写sass或者less，然后编译为css。 任意新建一个文件夹，该文件夹将被当做是我们目前的项目目录。在该目录中安装gulp-sass插件 1&gt; npm install gulp-sass 安装完成之后，我们可以看到目录中生成了一个叫做node-modules的文件夹，gulp-sass插件就被安装在node-modules中。 在该目录下新建一个叫做gulpfile.js的文件，并输入以下代码 1234567891011// gulpfile.js&apos;use strict&apos;;var gulp = require(&apos;gulp&apos;);var sass = require(&apos;gulp-sass&apos;);gulp.task(&apos;css&apos;, function() &#123; return gulp.src(&apos;./style/*.scss&apos;) .pipe(sass()) .pipe(gulp.dest(&apos;./style/&apos;))&#125;); 在上面的代码中，我创建了一个叫做css的任务，该任务识别style文件夹中的sass文件，通过sass()将sass文件转换成css文件并保存在style中。 因此我们在项目根目录下创建style文件夹，文件夹里新建一个叫做test.scss的文件，随便写一点sass语法，就可以查看gulp能否编译成功 123456body &#123; margin: 0; div &#123; border: 1px solid red; &#125;&#125; 运行如下指令 1&gt; gulp css 在我的环境下， 1234➜ learn-gulp git:(master) ✗ gulp css[16:47:51] Using gulpfile ~/develop/me/learn-gulp/gulpfile.js[16:47:51] Starting &apos;css&apos;...[16:47:51] Finished &apos;css&apos; after 36 ms 成功运行之后，在style文件夹下面发现了一个新的css文件，test.css，这就是sass文件编译而来。 从上面的例子我们可以看出，gulp构建工具的关键就在gulpfile.js中，为了进一步感受gulp的魅力，我们下面引入更多的插件来管理css文件所有的插件在gulpfile.js中使用之前，都必须安装，安装通过npm install指令即可，插件名就是下面js中require后面的名字。 123456789101112131415161718192021222324252627282930313233&apos;use strict&apos;;var gulp = require(&apos;gulp&apos;);// css 相关插件var sass = require(&apos;gulp-sass&apos;); // 编译sassvar autoprefixer = require(&apos;gulp-autoprefixer&apos;); // 补全前缀var csscomb = require(&apos;gulp-csscomb&apos;); // 格式化css样式，排序var cssbeautify = require(&apos;gulp-cssbeautify&apos;); // 美化css样式var minifycss = require(&apos;gulp-minify-css&apos;); // 压缩css文件// 错误捕获var plumber = require(&apos;gulp-plumber&apos;);gulp.task(&apos;css&apos;, function() &#123; gulp.src(&apos;./style/*.scss&apos;) .pipe(plumber()) .pipe(sass()) .pipe(autoprefixer(&#123; browsers: [&apos;last 2 versions&apos;, &apos;Android &gt;= 4.0&apos;], cascade: true, //是否美化属性值 默认：true 像这样： //-webkit-transform: rotate(45deg); // transform: rotate(45deg); remove:true //是否去掉不必要的前缀 默认：true &#125;)) .pipe(csscomb()) .pipe(minifycss(&#123; aggressiveMerging: false, advanced: false, //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: &apos;ie7&apos;, //保留ie7及以下兼容写法 类型：String 默认：&apos;&apos;or&apos;*&apos; [启用兼容模式； &apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式] keepBreaks: true, //类型：Boolean 默认：false [是否保留换行] keepSpecialComments: &apos;*&apos; //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(gulp.dest(&apos;./style/&apos;)); &#125;); 这样的一个css任务，几乎就可以用于实际开发了。 但我们想要的最终效果是，只要我们保存了sass文件，那么gulp中我们定义的css任务就会自动执行，并且，浏览器中的页面，也会自动刷新。 而现在我们只能输入gulp css指令才能够完成编译，因此我们还需要做许多其他的配置。 gulp.watch 与 gulp-livereload插件 为了能够实现我们想要的效果，我们得借助插件gulp-livereload。通过这个插件，我们能够完成实现浏览器的自动刷新。想要实现这个效果，我们还得在chrome浏览器中安装livereload插件。如果能翻墙就很好办，如果不能翻墙那就自己想办法吧 - -！然后我们还要在gulpfile.js中的css任务中添加如下代码 123....pipe(gulp.dest(&apos;./style/&apos;)).pipe(livereload(&#123; quiet: true &#125;)); 为了能够检测到scss文件的变化，我们还得创建一个watch任务，用于监听文件变化 12345678gulp.task(&apos;watch&apos;, function() &#123; livereload.listen(); gulp.watch(&apos;./style/*.scss&apos;, [&apos;css&apos;]);&#125;) // 默认执行watch任务gulp.task(&apos;default&apos;, [&apos;watch&apos;]); 这样，就可以实现我们想要的效果了。在命令行中输入 1&gt; gulp 出现下面的提示 123456➜ learn-gulp git:(master) ✗ gulp[16:39:02] Using gulpfile ~/develop/me/learn-gulp/gulpfile.js[16:39:02] Starting &apos;watch&apos;...[16:39:02] Finished &apos;watch&apos; after 13 ms[16:39:02] Starting &apos;default&apos;...[16:39:02] Finished &apos;default&apos; after 7.08 μs 就表示gulp任务已经启动监听，然后在浏览器中点击一下livereload插件的图标，让中间的空心圆变成实心圆，改变scss文件并保存就能够自动刷新页面了。 文章的中间可能会有一些文件的创建没有说到，因此最好建议大家去github上的learn-gulp项目，所有的细节都在里面。配合本文的讲解，相信学会gulp不是难事。https://github.com/yangbo5207/learn-gulp这篇文章算是对gulp的一个简单入门，接下来的一篇文章我会为大家分析一下gulp的一些api，让大家能够轻松自如的编写gulpfile.js。","categories":[],"tags":[]},{"title":"获取当前元素的所有兄弟元素","slug":"javascript/获取当前元素的所有兄弟元素","date":"2016-08-11T16:00:00.000Z","updated":"2017-03-29T07:00:13.926Z","comments":true,"path":"2016/08/12/javascript/获取当前元素的所有兄弟元素/","link":"","permalink":"http://yoursite.com/2016/08/12/javascript/获取当前元素的所有兄弟元素/","excerpt":"","text":"12345678910111213141516171819202122232425/** * 当前元素的所有兄弟元素 * @param element * @returns &#123;Array&#125; */function getSiblings(element) &#123; var elements = []; //保存当前元素的前面所有元素和后面所有元素 //获取前面的兄弟节点 var ele = element.previousSibling; while (ele) &#123; if (ele.nodeType === 1) &#123; elements.push(ele); &#125; ele = ele.previousSibling; &#125; //获取后面的节点 ele = element.nextSibling; while (ele) &#123; if (ele.nodeType === 1) &#123; elements.push(ele); &#125; ele = ele.nextSibling; &#125; return elements;&#125;","categories":[],"tags":[]},{"title":"gulp指南","slug":"前端工具/gulp指南","date":"2016-08-04T16:00:00.000Z","updated":"2017-03-29T07:05:27.737Z","comments":true,"path":"2016/08/05/前端工具/gulp指南/","link":"","permalink":"http://yoursite.com/2016/08/05/前端工具/gulp指南/","excerpt":"gulp指南 全局安装1npm install -g gulp-cli 查看版本号(验证是否安装成功) 1gulp --v","text":"gulp指南 全局安装1npm install -g gulp-cli 查看版本号(验证是否安装成功) 1gulp --v 本地安装 1npm install --save gulp 在根目录下创建一个 gulpfile.js 启动gulp 12直接写：gulp 变量名如果是变量名 default，就只写gulp 在gulpfile.js中写入一下内容 123456//加载gulp第三方包var gulp = require('gulp'); //定义一个吃饭的任务gulp.task(\"变量名\",function()&#123; console.log(\"吃饭\")&#125;) gulp.taskgulp.task(name [, deps][, fn]) 作用：定义各种不同的任务 gulp.task(name, fn) gulp.task(name, deps, fn) gulp.task(name, fn(cb)) gulp.task(name, deps, fn(cb)) 123 gulp.task(&apos;任务名&apos;,[可选的参数，是一个数组，用来声明当前任务的依赖任务], func(任务执行函数))* 1. func 中可以接收一个参数 cb ，用来控制任务依赖的执行流程的* 2. gulp.src 如何控制执行流程 12345678910一：普通任务​```jsgulp.task(&apos;a&apos;, function () &#123; console.log(&apos;1 aaa&apos;)&#125;)gulp.task(&apos;b&apos;, function () &#123; console.log(&apos;2 bbb&apos;)&#125;) 二：任务之间的依赖 1234567891011gulp.task('a', function (cb) &#123; setTimeout(function () &#123; console.log('1 aaa') cb() &#125;, 1000)&#125;)// b 任务依赖的 a 任务中的回调函数如果不调用，b 任务是不会执行的gulp.task('b', ['a'], function () &#123; console.log('2 bbb')&#125;) 三：gulp 流控制 12345678910gulp.task('a', function () &#123; // 当任务中是一个 gulp 流的时候则需要通过 return 来保证依赖中的执行顺序 return gulp.src() .pipe() // ...&#125;)gulp.task('b', ['a'], function () &#123; // doSomething&#125;) gulp.src 用来读文件12345678910111213141516171819 1. gulp.src 用来读文件- src参数：可以是字符串，- src参数也可以是数组：第一个参数表示想要拷贝的文件，第二个是不想要的文件 - `src/a.js` 指定具体文件； - `*` 匹配所有文件 例：`src/*.js` (包含src下的所有js文件)； - `**` 匹配0个或多个子文件夹 例：`src/**/*.js` (包含src的0个或多个子文件夹下的js文件)； - `&#123;&#125;` 匹配多个属性 例：`src/&#123;a,b&#125;.js` (包含a.js和b.js文件) src/*.&#123;jpg,png,gif&#125;(src下的所有jpg/png/gif文件)； - `!` 排除文件 例：`!src/a.js` (不包含src下的a.js文件)；```js//src参数：可以是字符串，//例子：查找所有的css：gulp.src(&apos;./src/css/**/*.css&apos;)gulp.task(&quot;变量名&quot;,function()&#123; gulp.src(&apos;./src/css/**/*.css&apos;) .pipe(gulp.dest(&apos;./dist/&apos;))&#125;) gulp.dest(path[, options]) gulp.dest 用来写文件作用：构建任务完成后资源存放的路径 gulp.watch(glob[, opts], tasks) 监视指定资源的改动，然后可以调用响应的任务处理 gulp.watch(glob [, opts, cb])gulp.src 和gulp.dest的例子12345678910111213141516171819202122232425262728/** * gulp.src 用来读文件 * gulp.dest 用来写文件 */var gulp = require('gulp')gulp.task('copy-index', function () &#123; // 通过 gulp.src() 读取到文件内容，然后通过 pipe() 方法，将读到的内容顺着管道流入 gulp.dest() 指定的目录中 gulp.src('./src/index.html') .pipe(gulp.dest('./dist/'))&#125;)gulp.task('copy-js', function () &#123; // gulp.src('./src/js/*.js') // .pipe(gulp.dest('./dist/js')) gulp.src('./src/js/**/*.js') .pipe(gulp.dest('./dist/js/'))&#125;)gulp.task('copy-css', function () &#123; // gulp.src(['./src/css/main.css', './src/css/login/login.css']) // .pipe(gulp.dest('./dist/css')) gulp.src(['./src/css/**/*.css', '!./src/css/haha.css']) .pipe(gulp.dest('./dist/css'))&#125;) 简单的例子：1234567891011var gulp = require('gulp'); //加载gulp第三方包//定义一个吃饭的任务gulp.task(\"eat\",function()&#123; console.log(\"吃饭\")&#125;)启动gulp 就直接写 gulp eat//default是一个比较特殊的人物名 可以直接通过 **gulp** 命令来执行gulp.task(\"default\",function()&#123; console.log(\"吃饭\")&#125;) 9.启动gulp 启动gulp 就直接写 gulp eat default是一个比较特殊的人物名 可以直接通过 gulp 命令来执行 10.编译less文件 编译LESS文件 1234567891011121314151617+ `npm install gulp-less`+ ```javascript var gulp = require(&apos;gulp&apos;) var less = require(&apos;gulp-less&apos;) gulp.task(&apos;less&apos;, function () &#123; gulp.src(&apos;./src/less/**/*.less&apos;) // 产生一坨数据 .pipe(less()) // 通过 pipe 将上一步 src 读取到的数据进入 less 插件，less 插件将处理过后的数据再次吐出来 .pipe(gulp.dest(&apos;./dist/css&apos;)) // 这里通过 pipe 管道接收上一个 less 吐出来的数据，经由 gulp.dest() 写入指定的目录路径 &#125;) // 该任务用来监视某个文件，当文件发生变化，则执行响应的任务 gulp.task(&apos;watch-less&apos;, [&apos;less&apos;], function () &#123; gulp.watch(&apos;./src/less/**/*.less&apos;, [&apos;less&apos;]) &#125;) 任务依赖 第一种情况：当异步加载的时候，需要在function中加callback 12345678910111213141516171819202122232425262728/** * 任务依赖 * gulp.task('任务名',[可选的参数，是一个数组，用来声明当前任务的依赖任务], func(任务执行函数)) * 1. func 中可以接收一个参数 cb ，用来控制任务依赖的执行流程的 * 2. gulp.src 如何控制执行流程 */var gulp = require('gulp')// 当依赖了 a 任务的任务 ab 在执行的时候，会先来执行 a// 发现 a 的执行函数有一个参数：callback，则 ab 必须等待 a 内部调用了 callback 才会继续执行gulp.task('a', function (callback) &#123; console.log('a开始了') setTimeout(function () &#123; console.log('a 中的定时器到了：aaa') callback() // callback() 调用就是告诉依赖了 a 任务的某个任务。我执行完了，你可以继续了 &#125;, 1000) console.log('a结束了')&#125;)gulp.task('b', function () &#123; console.log('bbb')&#125;)// 这里的任务的依赖是并行执行的，ab 任务不会等待 a 或者 b 完全执行结束才执行自己gulp.task('ab', ['a', 'b'], function () &#123; console.log('aaabbb')&#125;) 第二种情况 1234567891011121314151617/*** 对于普通的 API，通过 callback 来控制流程* 而对于 gulp 的原生的读写文件API，通过 return 实现流程控制*/ var gulp = require('gulp') var less = require('gulp-less') var cssnano = require('gulp-cssnano') var del = require('del') gulp.task('clear', function (callback) &#123;del('./dist/') .then(function () &#123; callback() &#125;) }) gulp.task(‘less’, [‘clear’], function () { // 如果是依赖 less 的任务，需要依赖于 less 的结果 // 则必须在 gulp.src() 之前加入 return 才可以实现流程控制 return gulp.src(‘./src/less/*/.less’) .pipe(less()) .pipe(gulp.dest(&apos;./dist/css/&apos;)) }) gulp.task(&apos;cssmin&apos;, [&apos;less&apos;], function () { gulp.src(&apos;./dist/css/**/*.css&apos;) .pipe(cssnano()) .pipe(gulp.dest(&apos;./dist/mincss&apos;)) }) 压缩 css压缩 gulp-cssnano 先安装 npm install gulp-cssnano 然后引用 js 压缩 gulp-uglify 先安装 npm install gulp-uglify 然后引用 123var gulp = require(&apos;gulp&apos;)var less = require(&apos;gulp-less&apos;)var cssnano = require(&apos;gulp-cssnano&apos;) ​ 常用插件 插件名称 作用 del 删除文件或文件夹 gulp-less 编译LESS文件 gulp-rname 重命名文件 gulp-imagemin 图片压缩 gulp-uglify 压缩Javascript gulp-concat 合并 js 文件 gulp-concat-css 合并 css 文件 gulp-cssnano 压缩 css gulp-htmlmin 压缩HTML gulp-nunjucks 模板引擎 gulp-rev 添加版本号 gulp-rev-collector 内容替换 gulp-useref gulp-if gulp-load-plugins 依赖自动加载 gulp-useref 自动合并打包处理 gulp-wrap 包装内容 gulp-angular-templatecache AngularJS 模板缓存 browser-sync 和 gulp 配合使用实现文件改变执行某个任务后自动刷新 yargs 获取命令行参数 gulp-if 根据判断执行某个插件 http-proxy-middleware http 代理插件 ## 参考网址 官方：http://gulpjs.com/ 中文官网：http://www.gulpjs.com.cn/ npm：https://www.npmjs.com/package/gulp Github：https://github.com/gulpjs/gulp Gitbook：https://wizardforcel.gitbooks.io/gulp-doc/content/2.html","categories":[],"tags":[]},{"title":"封装page方法","slug":"javascript/封装page方法","date":"2016-07-19T16:00:00.000Z","updated":"2017-03-29T07:14:10.924Z","comments":true,"path":"2016/07/20/javascript/封装page方法/","link":"","permalink":"http://yoursite.com/2016/07/20/javascript/封装page方法/","excerpt":"","text":"原生的js中都有兼容性问题，相对单独写起来比较麻烦，所以就把page方法进行封装，方便以后重用 123456789101112131415161718192021222324//封装pageXvar evtTools=&#123; getEvt:function (e) &#123; return e||window.event; &#125;, left:function() &#123; return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0; &#125;, top:function()&#123; return window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0; &#125;, getClientX:function (e) &#123; return this.getEvt(e).clientX; &#125;, getClientY:function (e) &#123; return this.getEvt(e).clientY; &#125;, getPageX:function (e) &#123; return this.getEvt(e).pageX?this.getEvt(e).pageX:this.getClientX(e)+this.left(); &#125;, getPageY:function (e) &#123; return this.getEvt(e).pageY?this.getEvt(e).pageY:this.getClientY(e)+this.top(); &#125;&#125;;","categories":[],"tags":[]},{"title":"获取任意一个元素中的第一个子元素","slug":"javascript/获取任意一个元素中的第一个子元素","date":"2016-06-09T16:00:00.000Z","updated":"2017-03-29T07:04:42.093Z","comments":true,"path":"2016/06/10/javascript/获取任意一个元素中的第一个子元素/","link":"","permalink":"http://yoursite.com/2016/06/10/javascript/获取任意一个元素中的第一个子元素/","excerpt":"","text":"12345678910111213141516171819/** * * @param element --任意一个元素 * @returns &#123;*&#125;----返回值是一个节点 */function getFirstElement(element) &#123; if (element.firstElementChild) &#123; return element.firstElementChild; &#125; else &#123; //IE8 不兼容 var node = element.firstChild; //判断当前的这个节点是不是标签 while (node &amp;&amp; node.nodeType != \"1\") &#123; //此时node不是标签,继续获取这个node的下一个兄弟节点 node = node.nextSibling; &#125; return node; &#125;&#125;","categories":[],"tags":[]},{"title":"三大系列——element元素结点属性","slug":"javascript/三大系列——element元素结点属性","date":"2016-04-14T16:00:00.000Z","updated":"2017-03-24T01:56:08.966Z","comments":true,"path":"2016/04/15/javascript/三大系列——element元素结点属性/","link":"","permalink":"http://yoursite.com/2016/04/15/javascript/三大系列——element元素结点属性/","excerpt":"","text":"之前看过这样的文章，总结不全，三大系列相当重要，结合文章加自己的理解整理了整理 区别client、offset、scroll系列以及event的几个距离属性 offset系列offsetWidth 和offsetHeightelement.offsetWidth是一个只读属性，它包括了：css width + padding+border+垂直滚动条宽度 这里的滚动条就是单纯滚动条的意思，不包括不可见的部分哦。 而element.offsetHeight与之类似，只是改为垂直方向而已。 1&lt;!--more--&gt; offsetParentelement.offsetParent是一个只读属性，返回一个对象的引用，这个引用指向了element（调用offsetParent）的最近一个使用了定位（absolute、relative）的父元素，如果没有定位了的父元素，则指向根元素（标准模式下为 html；quirks 模式下为 body）。 兼容性： 在 Webkit 中，如果元素为隐藏的（该元素或其祖先元素的 style.display 为 “none”），或者该元素的 style.position 被设为 “fixed”，则该属性返回 null。 在 IE 9 中，如果该元素的 style.position 被设置为 “fixed”，则该属性返回 null。（display:none 无影响。） 3.offsetTop和offsetLeft element.offsetTop 和 element.offsetLeft 都是相对于offsetParent的内边距（外）边界的。 也就是返回对象元素边界的左上角顶点相对于offsetParent的左上角顶点的水平偏移量。这里，元素对象左上角顶点是要从border开始算（如果有的话，即border边界距离offsetParent padding边界的距离，不是从从元素的margin开始算），offsetParent的左上角是指其padding边界。 参考资料： 前端攻城狮学习笔记九：让你彻底弄清offset HTMLElement.offsetParent client系列clientHeight和clientWidthelement.clientHeight表示元素可视区域的高度，包括可视区域中元素的 CSS height+padding 不包括边框、滚动条、不可见部分、margin。 clientWidth类似，只不过是水平方向。 clientLeft和clientTop是元素 padding外边界与父元素的padding边界的距离-元素的offsetLeft值，就等于元素的左边框宽度。？？？不知道理解对没 clientTop与之类似。 scroll系列scrollHeight和scrollWidthelement.scrollHeight属性是只读的，它包括： 可见CSS高度+padding+border+由于overflow设置为隐藏或者scroll而不可见的内容高度。 可看出和offsetHeight的区别就是多了个不可见内容区高度。scrollWidth与之类似。 scrollTop和scrollLeft即是被scroll了的内容区域的高度和宽度，隐藏不可见的内容区域。 注意： 元素设置了overflow: scroll，滚动条是占据了元素原来CSS宽度的一部分，即加了滚动条后，元素CSS中定义的属性width=滚动条宽度+content 宽度。边框是加在滚动条外面的，而padding则是加在滚动条内部，内容区之外的。 一个盒子设置了margin-top，是和别的盒子间的垂直距离，这个别的盒子不包括父盒子，也就是说，内部盒子顶部和父盒子边界的距离不变，而是整个父盒子顶部都和更外部的环境相距了margin-top值的距离。 参考资料： Mozilla文档上的图示描述得很明白 https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollHeight event事件对象属性 下面几个是event事件对象的属性，可获取鼠标的位置： 1.clientX，clientY 表示鼠标位置距离可视窗口边缘的距离。它们是事件对象的属性。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。 2.pageX，pageY 表示鼠标位置距离整个文档页面边缘（左和上边缘）的距离 3.screenX，screenY 表示鼠标位置距离屏幕边缘的距离 4.offsetX，offsetY： 鼠标相对于事件源元素（srcElement）的X,Y坐标，只有IE事件有这2个属性，标准事件没有对应的属性。 来看个小例子，跟随鼠标的提示框： //css #info {position:absolute;} //html //js document.onmousemove=function(ev){ var oEvent=ev||event; var info=document.getElementById(‘info’); //获取不可见内容高度 var scrollTop=document.documentElement.scrollTop|| document.body.scrollTop//???混杂模式和标准模式下都能工作？ info.style.left=oEvent.clientX+’px’; info.style.top=oEvent.clientY+scrollTop+’px’; //可视区高度+scrolled的高度 } document.documentElement指向document对象的根元素，在html文档中就是html元素。 经验：只要在用到clientX和clientY的地方都最好加上scroll值。 scroll 获取元素内容的大小和位置 滚动条滚动距离 层中设置文字内容,然后获取层的scrollHeight 设置层中的overflow:auto 查看scrollTop 区别：1.scrollTop : 滚动条滚动距离 说明：chrome下他会以为滚动条是文档元素的，所以需要做兼容 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; scrollHeight 返回整个元素的高度+padding（包括子元素把父元素撑开隐蔽的地方） 说明:scrollHeight问题比较大 1、当子元素的高度大于父元素高度：标准浏览器下包含子元素样式高+padding+margin+border+父元素padding-top的值，ie7以下包含子元素样式高+padding+margin+border+父元素padding-top和padding-bottom 2、当子元素的高度小于父元素高度：标准浏览器下包含父元素样式高+padding，ie7以下只计算子元素的高度+父元素的padding 二、pageX和pageY e.clientX和e.clientY是可视区域的坐标 e.pageX和e.pageY才是真正的文档的坐标 兼容的写法是: ​e.client+document.body.scrollTop==e.pageY","categories":[],"tags":[]},{"title":"返回指定的日期格式","slug":"javascript/返回指定时间格式","date":"2016-04-09T16:00:00.000Z","updated":"2017-03-29T06:27:47.655Z","comments":true,"path":"2016/04/10/javascript/返回指定时间格式/","link":"","permalink":"http://yoursite.com/2016/04/10/javascript/返回指定时间格式/","excerpt":"","text":"1234567891011121314151617181920212223242526/** * 获取当前的日期，显示指定的格式 * @param time----&gt;日期对象 * @returns &#123;string&#125; 返回指定字符串的日期格式 */function getDayTime(time) &#123; //new Date() 获取今天当前的日期 //获取年份 var year = time.getFullYear(); //获取月份 var month = time.getMonth() + 1; //获取当天日期 var day = time.getDate(); //获取时 var hour = time.getHours(); //获取分 var minutes = time.getMinutes(); //获取秒 var second = time.getSeconds(); month = month &lt; 10 ? \"0\" + month : month; day = day &lt; 10 ? \"0\" + day : day; hour = hour &lt; 10 ? \"0\" + hour : hour; minutes = minutes &lt; 10 ? \"0\" + minutes : minutes; second = second &lt; 10 ? \"0\" + second : second; return year + \"年\" + month + \"月\" + day + \"日 \" + second + \":\" + minutes + \":\" + second;&#125;","categories":[],"tags":[]},{"title":"移动端 H5 页面注意事项","slug":"移动端/移动端 H5 页面注意事项","date":"2016-02-17T16:00:00.000Z","updated":"2017-04-06T02:52:19.084Z","comments":true,"path":"2016/02/18/移动端/移动端 H5 页面注意事项/","link":"","permalink":"http://yoursite.com/2016/02/18/移动端/移动端 H5 页面注意事项/","excerpt":"之前在做手机端的时候，自己也踩过好多坑，自己也做了一些笔记，正好在掘金上看到这篇文章，觉得写得还不错，结合自己的理解和这篇文章，整理了整理。 1. 单个页面内容不能过多设计常用尺寸：750 x 1334 / 640 x 1134，包含了手机顶部信号栏的高度。 移动端H5活动页面常常需要能够分享到各种社交App中，常用的有 微信、QQ 等。 使用移动设备查看页面时会发现，在微信浏览器中有 顶部导航栏，在qq内置浏览器里不止有 顶部导航，底部也有 操作栏（safari浏览器也一样），这些都会占用设计稿显示区域，因此在 设计环节 就需要考虑内容的多少，页面底部要 预留一定的空白，这样在微信或qq中才不会被遮住。","text":"之前在做手机端的时候，自己也踩过好多坑，自己也做了一些笔记，正好在掘金上看到这篇文章，觉得写得还不错，结合自己的理解和这篇文章，整理了整理。 1. 单个页面内容不能过多设计常用尺寸：750 x 1334 / 640 x 1134，包含了手机顶部信号栏的高度。 移动端H5活动页面常常需要能够分享到各种社交App中，常用的有 微信、QQ 等。 使用移动设备查看页面时会发现，在微信浏览器中有 顶部导航栏，在qq内置浏览器里不止有 顶部导航，底部也有 操作栏（safari浏览器也一样），这些都会占用设计稿显示区域，因此在 设计环节 就需要考虑内容的多少，页面底部要 预留一定的空白，这样在微信或qq中才不会被遮住。 如下图（QQ内置浏览器）：页面设计尺寸为 750 x 1334，顶部占用 150px，底部占用 110px，共占用了 260px，因此设计稿内容应控制在 1334-260=1074px 的高度内。编写代码时，使用 Chrome 浏览器模拟设备大小，将该尺寸（750*1074）存下来，用于实时查看移动端页面效果。 如果页面已经写好了，就只能按照上面的尺寸进行内容的调整了，缩小元素间距，缩放图片大小等。 分享下我的失败尝试： 如果对整个页面进行缩放（使用 meta 标签），按照设计稿的比例，在高度满足的情况下宽度会偏小，两边会有白底； 就算使用 rem 作为相关间距的单位，也没有办法找到一个合适的比例在两种高度（微信/QQ）下切换，因此统一调成适配 QQ 的，这样就算在微信下有多余的空白，固定底部的引导下滑箭头也能使其不会过于突兀。 2. 标题简短移动端浏览器导航条宽度有限，简短的标题可以使其展示完整。 3. 二维码图片使用 img 标签引入二维码图片不要写为元素背景，不然长按没有办法触发扫描功能。应使用 img 标签引入，如下： 1&lt;img src=\"images/qrcode.png\" title=\"\" alt=\"\"&gt; 4. 二维码图片记得扫描测试有时候扫描二维码之后，会跳转至某个地址，不幸的话QQ或者微信会对这个地址进行温馨提醒，如下图所示： 这样会阻止部分用户继续访问，从而无法很好的将用户引导到活动想要推广的产品/品牌页面，如 App 的下载页面等。因此二维码的扫描测试不能少。 举个例子，如果二维码扫描结果是应用的下载地址的话，可以使用应用宝的微下载地址来生成二维码，这是不会被“温馨提醒”的。 5. 使用 Gulp 拼合图片如果打算先布局，后使用自动化工具（如：gulp-sprite-generator2）将图片拼起来，减少请求数，需要注意：在编写 CSS 的时候，图片宽高应固定，图片拼合后才能通过定位和显示区域的宽高来展示图片。 举个例子，如果布局时 width: 100%; background-position: center;，使用工具拼合图片后，该元素区域（100% 的宽度）内会将其他图片显示出来，这不是我们想要看到的。 建议先将图片拼起来再布局，可以使用：gulp.spritesmith，一步获取合并的精灵图和对应的 css 文件。 6. 关于链接的分享-QQ如果将页面链接直接复制分享给其他人，在手机上接收链接消息的用户可能会看到链接的相关信息，如页面标题、描述和图片。相关信息设置方式如下： 1234&lt;title&gt;QQ中链接的标题由此处获取&lt;/title&gt;&lt;meta name=\"description\" content=\"QQ中链接的描述由此处获取\"&gt;&lt;!-- QQ默认获取的图片有可能出现缩放问题，效果不佳，可以通过如下方法进行设置 --&gt;&lt;meta itemprop=\"image\" content=\"http://*.*.com/static/images/share.png\" /&gt; 可参考 手机QQ接口文档：setShareInfo。 问题：即使使用了如上的 image 设置方法，还是没能显示预期图片？解决：确定下你发送的链接格式，会不会有所省略，如：somedomain/ 或者 somedomain/index，正确的应为 somedomain/index.html，才能正确解析到图片。 如果是打开链接后，在QQ内置浏览器里选择将页面分享出去，那一般不会出错。 7. 图片压缩使用自动化工具 gulp-imagemin（教程） 来压缩图片，效果举例：101 KB =&gt; 80.7 KB。后来我使用了在线工具 Tinypng 又进行了一次压缩，效果举例：（上面使用 gulp-imagemin 压缩过的图片）80.7 KB =&gt; 38.1 KB，可见光使用自动化工具来压缩是不够的，大部分图片仍存在较大的压缩空间，可以再扔到 Tinypng 里压缩一下看看。 在线的 Tinypng 可以无限次使用，如果想要使用其 API 来进行压缩自动化的话，可以使用 gulp-tinypng 等插件，但是有每月压缩图片数量限制，每月前500张图片免费，其他收费情况参考官网说明。使用其 API 还需要获取 API Key，这里可以获取。个人觉得想要免费的话使用 API 会有数量限制，时刻惦记着数量有点心累，不如直接使用在线工具，也不麻烦~ 8. Loading首屏 Loading，代码段分享，拿走即用~ 12345678910111213141516171819202122232425262728293031323334353637383940414243function loading()&#123; function Load()&#123;&#125; Load.prototype.loadImgs = function(urls,callback) &#123; this.urls = urls; this.imgNumbers = urls.length; this.loadImgNumbers = 0; var that =this; for(var i=0;i&lt;urls.length;i++)&#123; var obj = new Image(); obj.src = urls[i]; obj.onload = function()&#123; that.loadImgNumbers++; callback(parseInt((that.loadImgNumbers/that.imgNumbers)*100)); &#125; &#125; &#125;; var loader = new Load(); loader.loadImgs([ // 将所有需要加载的图片地址写于此处 \"http://domain/site/dist/img/XX.png\", \"http://domain/site/dist/img/XX.png\", \"http://domain/site/dist/img/XX.png\", \"http://domain/site/dist/img/XX.png\", \"http://domain/site/dist/img/XX.png\", \"http://domain/site/dist/img/XX.png\", \"http://domain/site/dist/img/XX.png\" ],function(percent)&#123; // 假设显示百分比的元素为 $(\".percent\") $(\".percent\").text(percent+'%'); // 加载结束后，隐藏相应的 loading 或遮罩 if(percent==100) &#123; $(\".mask\").css('display','none'); &#125; &#125;);&#125;// 执行 loading 方法loading(); 9. CSS 动画属性前缀 webkit使用 CSS3 来制作动画效果的话，webkit 前缀一定记得加，要不然在某些手机下动画效果是没有的。如下： 123456789101112131415161718192021222324252627282930-webkit-animation: f .8s 2s forwards ease-in-out;animation: f .8s 2s forwards ease-in-out;@-webkit-keyframes f &#123; 0% &#123; opacity: 0; -webkit-transform: translate3d(750px,0,0); transform: translate3d(750px,0,0) &#125; to &#123; opacity: 1; -webkit-transform: translateZ(0); transform: translateZ(0) &#125;&#125;@keyframes f &#123; 0% &#123; opacity: 0; -webkit-transform: translate3d(750px,0,0); transform: translate3d(750px,0,0) &#125; to &#123; opacity: 1; -webkit-transform: translateZ(0); transform: translateZ(0) &#125;&#125; 推荐使用自动化工具来处理未加前缀的 CSS 文件，如 gulp-autoprefixer。 10. Swiper.js &amp; Animate.css你只需要 Swiper.js 和 Animate.css 即可打造（简单的）移动端 H5 活动页面~Swiper 是纯 javascript 打造的滑动特效插件，面向手机、平板电脑等移动终端。Animate.css 是纯 CSS 编写而成的动画库，包含多种常见的 CSS 动画。引用 Swiper.js，同时在 Animate.css 中寻找需要的动画效果复制粘贴进 css 文件即可，完全不必引用 Animate.css。 11. 使用 Meta 标签进行页面缩放1234567891011121314151617&lt;!-- 以下代码默认设计稿尺寸为 640 x 1134 --&gt;&lt;meta id=\"viewport\" content=\"width=device-width, user-scalable=yes,initial-scale=1\" name=\"viewport\" /&gt;&lt;script&gt; var detectBrowser = function(name) &#123; if(navigator.userAgent.toLowerCase().indexOf(name) &gt; -1) &#123; return true; &#125; else &#123; return false; &#125; &#125;; var width = parseInt(window.screen.width); var scale = width/640; // 根据设计稿尺寸进行相应修改：640=&gt;? var userScalable = 'no'; if(detectBrowser(\"qq/\")) userScalable = 'yes'; document.getElementById('viewport').setAttribute( 'content', 'target-densitydpi=device-dpi,width=640,user-scalable='+userScalable+',initial-scale=' + scale); // 这里也别忘了改：640=&gt;?&lt;/script&gt; 利用 meta 标签对页面进行缩放，使得我们可以直接根据设计稿来进行页面的编写，不用再进行单位的换算等等，省却了很多麻烦。 12. 微信二维码问题01：同一个页面里要是有两个二维码，长按扫描总是只能扫出 左侧/第一个 二维码。解决：可视区域内只能出现一个二维码。 02：使用 meta 标签缩放页面后长按二维码图片无反应。解决：使用了以下代码之后，就能长按识别二维码了~ 123456&lt;!--同一张二维码图片--&gt;&lt;!--下面这张 opacity 为 0，隐藏起来，但是实际存在，并且宽为 100%，屏幕有多大就多大--&gt;&lt; img style=\"right:0; top:0; height: auto;width: 100%;opacity: 0;position: absolute;\" src=\"二维码图片地址\"&gt;&lt;!--下面这张是呈现给用户看的--&gt;&lt; img src=\"二维码图片地址\" title=\"qrcode\" alt=\"qrcode\"&gt;&lt;!--PS: img 标签前面的空格记得去掉，这里加上空格是因为简书有 bug，针对 img 标签代码渲染会出错--&gt;","categories":[],"tags":[]},{"title":"Flex布局新旧混合写法","slug":"css/Flex布局新旧混合写法详解（兼容微信）","date":"2015-06-17T16:00:00.000Z","updated":"2017-03-05T10:47:16.474Z","comments":true,"path":"2015/06/18/css/Flex布局新旧混合写法详解（兼容微信）/","link":"","permalink":"http://yoursite.com/2015/06/18/css/Flex布局新旧混合写法详解（兼容微信）/","excerpt":"首先还是从两个版本的语法开始讲吧，这里还是假设flex容器为 .box ，子元素为 .item 。 旧语法篇 定义容器的display属性 .box{ display: -moz-box; /*Firefox*/ display: -webkit-box; /*Safari,Opera,Chrome*/ display: box; }","text":"首先还是从两个版本的语法开始讲吧，这里还是假设flex容器为 .box ，子元素为 .item 。 旧语法篇 定义容器的display属性 .box{ display: -moz-box; /*Firefox*/ display: -webkit-box; /*Safari,Opera,Chrome*/ display: box; } 容器属性 1.box-pack 属性 box-pack定义子元素主轴对齐方式。 .box{ -moz-box-pack: center; /*Firefox*/ -webkit-box-pack: center; /*Safari,Opera,Chrome*/ box-pack: center; } box-pack属性总共有4个值： .box{ box-pack: start | end | center | justify; /*主轴对齐：左对齐（默认） | 右对齐 | 居中对齐 | 左右对齐*/ } 2.box-align 属性 box-align定义子元素交叉轴对齐方式。 .box{ -moz-box-align: center; /*Firefox*/ -webkit-box-align: center; /*Safari,Opera,Chrome*/ box-align: center; } box-align属性总共有5个值： .box{ box-align: start | end | center | baseline | stretch; /*交叉轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 文本基线对齐 | 上下对齐并铺满*/ } 3.box-direction 属性 box-direction定义子元素的显示方向。 .box{ -moz-box-direction: reverse; /*Firefox*/ -webkit-box-direction: reverse; /*Safari,Opera,Chrome*/ box-direction: reverse; } box-direction属性总共有3个值： .box{ box-direction: normal | reverse | inherit; /*显示方向：默认方向 | 反方向 | 继承子元素的 box-direction*/ } 4.box-orient 属性 box-orient定义子元素是否应水平或垂直排列。 .box{ -moz-box-orient: horizontal; /*Firefox*/ -webkit-box-orient: horizontal; /*Safari,Opera,Chrome*/ box-orient: horizontal; } box-orient属性总共有5个值： .box{ box-orient: horizontal | vertical | inline-axis | block-axis | inherit; /*排列方向：水平 | 垂直 | 行内方式排列（默认） | 块方式排列 | 继承父级的box-orient*/ } 5.box-lines 属性 box-lines定义当子元素超出了容器是否允许子元素换行。 .box{ -moz-box-lines: multiple; /*Firefox*/ -webkit-box-lines: multiple; /*Safari,Opera,Chrome*/ box-lines: multiple; } box-lines属性总共有2个值： .box{ box-lines: single | multiple; /*允许换行：不允许（默认） | 允许*/ } 子元素属性 1.box-flex 属性 box-flex定义是否允许当前子元素伸缩。 .item{ -moz-box-flex: 1.0; /*Firefox*/ -webkit-box-flex: 1.0; /*Safari,Opera,Chrome*/ box-flex: 1.0; } box-flex属性使用一个浮点值： .item{ box-flex: &lt;value&gt;; /*伸缩：&lt;一个浮点数，默认为0.0，即表示不可伸缩，大于0的值可伸缩，柔性相对&gt;*/ } 2.box-ordinal-group 属性 box-ordinal-group定义子元素的显示次序，数值越小越排前。 .item{ -moz-box-ordinal-group: 1; /*Firefox*/ -webkit-box-ordinal-group: 1; /*Safari,Opera,Chrome*/ box-ordinal-group: 1; } box-direction属性使用一个整数值： .item{ box-ordinal-group: &lt;integer&gt;; /*显示次序：&lt;一个整数，默认为1，数值越小越排前&gt;*/ } 新版语法 定义容器的display属性 .box{ display: -webkit-flex; /*webkit*/ display: flex; } /行内flex/ .box{ display: -webkit-inline-flex; /*webkit*/ display:inline-flex; } 容器样式 .box{ flex-direction: row | row-reverse | column | column-reverse; /*主轴方向：左到右（默认） | 右到左 | 上到下 | 下到上*/ flex-wrap: nowrap | wrap | wrap-reverse; /*换行：不换行（默认） | 换行 | 换行并第一行在下方*/ flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; /*主轴方向和换行简写*/ justify-content: flex-start | flex-end | center | space-between | space-around; /*主轴对齐方式：左对齐（默认） | 右对齐 | 居中对齐 | 两端对齐 | 平均分布*/ align-items: flex-start | flex-end | center | baseline | stretch; /*交叉轴对齐方式：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/ align-content: flex-start | flex-end | center | space-between | space-around | stretch; /*多主轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 上下平均分布*/ } 子元素属性 .item{ order: &lt;integer&gt;; /*排序：数值越小，越排前，默认为0*/ flex-grow: &lt;number&gt;; /* default 0 */ /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: &lt;number&gt;; /* default 1 */ /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/ flex-basis: &lt;length&gt; | auto; /* default auto */ /*固定大小：默认为0，可以设置px值，也可以设置百分比大小*/ flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ] /*flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，*/ align-self: auto | flex-start | flex-end | center | baseline | stretch; /*单独对齐方式：自动（默认） | 顶部对齐 | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/ } 兼容写法 首先是定义容器的 display 属性： .box{ display: -webkit-box; /* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */ display: -moz-box; /* 老版本语法: Firefox (buggy) */ display: -ms-flexbox; /* 混合版本语法: IE 10 */ display: -webkit-flex; /* 新版本语法: Chrome 21+ */ display: flex; /* 新版本语法: Opera 12.1, Firefox 22+ */ } 由于旧版语法并没有列入W3C标准，所以这里不用写 display:box ，下面的语法也是一样的。 这里还要注意的是，如果子元素是行内元素，在很多情况下都要使用 display:block 或 display:inline-block 把行内子元素变成块元素（例如使用 box-flex 属性），这也是旧版语法和新版语法的区别之一。 子元素主轴对齐方式 .box{ -webkit-box-pack: center; -moz-justify-content: center; -webkit-justify-content: center; justify-content: center; } 这里旧版语法有4个参数，而新版语法有5个参数，兼容写法新版语法的 space-around 是不可用的： .box{ box-pack: start | end | center | justify; /*主轴对齐：左对齐（默认） | 右对齐 | 居中对齐 | 左右对齐*/ justify-content: flex-start | flex-end | center | space-between | space-around; /*主轴对齐方式：左对齐（默认） | 右对齐 | 居中对齐 | 两端对齐 | 平均分布*/ } 子元素交叉轴对齐方式 .box{ -webkit-box-align: center; -moz-align-items: center; -webkit-align-items: center; align-items: center; } 这里的参数除了写法不同，其实是功能是一样的： .box{ box-align: start | end | center | baseline | stretch; /*交叉轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 文本基线对齐 | 上下对齐并铺满*/ align-items: flex-start | flex-end | center | baseline | stretch; /*交叉轴对齐方式：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/ } 子元素的显示方向 子元素的显示方向可通过 box-direction + box-orient + flex-direction 实现，下面请看实例： 左到右 .box{ -webkit-box-direction: normal; -webkit-box-orient: horizontal; -moz-flex-direction: row; -webkit-flex-direction: row; flex-direction: row; } 右到左 .box{ -webkit-box-pack: end; -webkit-box-direction: reverse; -webkit-box-orient: horizontal; -moz-flex-direction: row-reverse; -webkit-flex-direction: row-reverse; flex-direction: row-reverse; } 这里补充说明一点： box 写法的 box-direction 只是改变了子元素的排序，并没有改变对齐方式，需要新增一个 box-pack 来改变对齐方式。 上到下 .box{ -webkit-box-direction: normal; -webkit-box-orient: vertical; -moz-flex-direction: column; -webkit-flex-direction: column; flex-direction: column; } 下到上 .box{ -webkit-box-pack: end; -webkit-box-direction: reverse; -webkit-box-orient: vertical; -moz-flex-direction: column-reverse; -webkit-flex-direction: column-reverse; flex-direction: column-reverse; } 是否允许子元素伸缩 .item{ -webkit-box-flex: 1.0; -moz-flex-grow: 1; -webkit-flex-grow: 1; flex-grow: 1; } .item{ -webkit-box-flex: 1.0; -moz-flex-shrink: 1; -webkit-flex-shrink: 1; flex-shrink: 1; } 上面是允许放大，box语法中 box-flex 如果不是0就表示该子元素允许伸缩，而flex是分开的，上面 flex-grow 是允许放大（默认不允许），下面的 flex-shrink 是允许缩小（默认允许）。box-flex 默认值为0，也就是说，在默认的情况下，在两个浏览器中的表现是不一样的： 这里还有一点，就是新旧语法的算法是不一样的，假设 box-flex 的值不等于0，旧语法中，如果有多余的空间，box-flex 的值越大，说明空白部分的占比越多，反之亦然： 而新版的语法中，放大的比例是直接按 flex-grow 的值来分配的，flex-grow 的缩放会覆盖 flex-shrink:0，看例子： 参数： .item{ box-flex: &lt;value&gt;; /*伸缩：&lt;一个浮点数，默认为0.0，即表示不可伸缩，大于0的值可伸缩，柔性相对&gt;*/ flex-grow: &lt;number&gt;; /* default 0 */ /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: &lt;number&gt;; /* default 1 */ /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/ } 子元素的显示次序 .item{ -webkit-box-ordinal-group: 1; -moz-order: 1; -webkit-order: 1; order: 1; }","categories":[],"tags":[]},{"title":"Javascript 中 apply、call、bind","slug":"javascript/深入浅出妙用 Javascript 中 apply、call、bind","date":"2015-04-09T16:00:00.000Z","updated":"2017-03-05T07:37:04.020Z","comments":true,"path":"2015/04/10/javascript/深入浅出妙用 Javascript 中 apply、call、bind/","link":"","permalink":"http://yoursite.com/2015/04/10/javascript/深入浅出妙用 Javascript 中 apply、call、bind/","excerpt":"通过这篇文章，能够清晰的提升对apply、call、bind的认识 apply、call 在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。 JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。","text":"通过这篇文章，能够清晰的提升对apply、call、bind的认识 apply、call 在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。 JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。 先来一个栗子： function fruits() {} fruits.prototype = { color: “red”, say: function() { console.log(“My color is “ + this.color); } } var apple = new fruits; apple.say(); //My color is red 但是如果我们有一个对象banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法： banana = { color: “yellow” } apple.say.call(banana); //My color is yellow apple.say.apply(banana); //My color is yellow 所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本栗子中banana没有say方法），但是其他的有（本栗子中apple有say方法），我们可以借助call或apply用其它对象的方法来操作。 apply、call 的区别 对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下： var func = function(arg1, arg2) { }; 就可以通过如下方式来调用： func.call(this, arg1, arg2); func.apply(this, [arg1, arg2]) 其中 this 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call 。 而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。 为了巩固加深记忆，下面列举一些常用用法： 1、数组之间追加 var array1 = [12 , “foo” , {name “Joe”} , -2458]; var array2 = [“Doe” , 555 , 100]; Array.prototype.push.apply(array1, array2); / array1 值为 [12 , “foo” , {name “Joe”} , -2458 , “Doe” , 555 , 100] / 2、获取数组中的最大值和最小值 var numbers = [5, 458 , 120 , -215 ]; var maxInNumbers = Math.max.apply(Math, numbers), //458 maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458 number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。 3、验证是否是数组（前提是toString()方法没有被重写过） functionisArray(obj){ returnObject.prototype.toString.call(obj) === &apos;[object Array]&apos; ; } 4、类（伪）数组使用数组方法 var domNodes = Array.prototype.slice.call(document.getElementsByTagName(“*”)); Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。 但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。 深入理解运用apply、call 下面就借用一道面试题，来更深入的去理解下 apply 和 call 。 定义一个 log 方法，让它可以代理 console.log 方法，常见的解决方法是： function log(msg) { console.log(msg); } log(1); //1 log(1,2); //1 上面方法可以解决最基本的需求，但是当传入参数的个数是不确定的时候，上面的方法就失效了，这个时候就可以考虑使用 apply 或者 call，注意这里传入多少个参数是不确定的，所以使用apply是最好的，方法如下： function log(){ console.log.apply(console, arguments); }; log(1); //1 log(1,2); //1 2 接下来的要求是给每一个 log 消息添加一个”(app)”的前辍，比如： log(“hello world”); //(app)hello world 该怎么做比较优雅呢?这个时候需要想到arguments参数是个伪数组，通过 Array.prototype.slice.call 转化为标准数组，再使用数组方法unshift，像这样： function log(){ var args = Array.prototype.slice.call(arguments); args.unshift(&apos;(app)&apos;); console.log.apply(console, args); }; bind 说完了 apply 和 call ，再来说说bind。bind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。 MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。 像这样： var foo = { bar : 1, eventBind: function(){ var _this = this; $(‘.someClass’).on(‘click’,function(event) { / Act on the event / console.log(_this.bar); //1 }); } } 由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题： var foo = { bar : 1, eventBind: function(){ $(‘.someClass’).on(‘click’,function(event) { / Act on the event / console.log(this.bar); //1 }.bind(this)); } } 在上述代码里，bind() 创建了一个函数，当这个click事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用bind()时传入的参数）。因此，这里我们传入想要的上下文 this(其实就是 foo )，到 bind() 函数中。然后，当回调函数被执行的时候， this 便指向 foo 对象。再来一个简单的栗子： var bar = function(){ console.log(this.x); } bar(); // undefined var func = bar.bind(foo); func(); // 3 这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。 有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？像这样： var bar = function(){ console.log(this.x); } var foo = { x:3 } var sed = { x:4 } var func = bar.bind(foo).bind(sed); func(); //? var fiv = { x:5 } var func = bar.bind(foo).bind(sed).bind(fiv); func(); //? 答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在Javascript中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。 apply、call、bind比较 那么 apply、call、bind 三者相比较，之间又有什么异同呢？何时使用 apply、call，何时使用 bind 呢。简单的一个栗子： var obj = { x: 81, }; var foo = { getX: function() { return this.x; } } console.log(foo.getX.bind(obj)()); //81 console.log(foo.getX.call(obj)); //81 console.log(foo.getX.apply(obj)); //81 三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。 也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。 再总结一下： apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind是返回对应函数，便于稍后调用；apply、call则是立即调用 。","categories":[],"tags":[]},{"title":"七种CSS方式让一个容器水平垂直居中","slug":"css/七种CSS方式让一个容器水平垂直居中","date":"2015-03-19T16:00:00.000Z","updated":"2017-03-05T09:02:39.968Z","comments":true,"path":"2015/03/20/css/七种CSS方式让一个容器水平垂直居中/","link":"","permalink":"http://yoursite.com/2015/03/20/css/七种CSS方式让一个容器水平垂直居中/","excerpt":"阅读目录方法一：position加margin方法二： diaplay:table-cell方法三：position加 transform方法四：flex;align-items: center;justify-content: center方法五：display:flex;margin:auto方法六：纯position方法七：兼容低版本浏览器，不固定宽高","text":"阅读目录方法一：position加margin方法二： diaplay:table-cell方法三：position加 transform方法四：flex;align-items: center;justify-content: center方法五：display:flex;margin:auto方法六：纯position方法七：兼容低版本浏览器，不固定宽高 总结这种css布局平时用的比较多，也是面试题常出的一个题，网上一搜一大丢，不过还是想自己总结一下。 这种方法比较多，本文只总结其中的几种，以便加深印象。效果图都为这个： 方法一：position加margin1234567/**html**/&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /**css**/.wrap &#123; width: 200px; height: 200px; background: yellow; position: relative; &#125;.wrap .center &#123; width: 100px; height: 100px; background: green; margin: auto; position: absolute; left: 0; right: 0; top: 0; bottom: 0; &#125; 兼容性：主流浏览器均支持，IE6不支持 方法二： diaplay:table-cell1234567/**html**/&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /*css*/.wrap &#123; width: 200px; height: 200px; background: yellow; display: table-cell; vertical-align: middle; text-align: center; &#125; .center &#123; display: inline-block; vertical-align: middle; width: 100px; height: 100px; background: green; &#125; 兼容性：由于display:table-cell的原因，IE6\\7不兼容 方法三：position加 transform1234567/**html**/&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /*css*/.wrap &#123; position: relative; background: yellow; width: 200px; height: 200px; &#125;.center &#123; position: absolute; background: green; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%); width: 100px; height: 100px; &#125; 兼容性：ie9以下不支持 transform，手机端表现的比较好。 方法四：flex;align-items: center;justify-content: center1234567/**html**/&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /*css*/.wrap &#123; background: yellow; width: 200px; height: 200px; display: flex; align-items: center; justify-content: center; &#125;.center &#123; background: green; width: 100px; height: 100px; &#125; 移动端首选 方法五：display:flex;margin:auto1234567/**html**/&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /*css*/.wrap &#123; background: yellow; width: 200px; height: 200px; display: flex; &#125;.center &#123; background: green; width: 100px; height: 100px; margin: auto; &#125; 移动端首选 方法六：纯position12345678910/**html**/&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /*css*/.wrap &#123; background: yellow; width: 200px; height: 200px; position: relative; &#125;/**方法一**/.center &#123; background: green; position: absolute; width: 100px; height: 100px; left: 50px; top: 50px; &#125;/**方法二**/.center &#123; background: green; position: absolute; width: 100px; height: 100px; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; &#125; 兼容性：适用于所有浏览器 方法六中的方法一计算公式如下： 子元素（conter）的left值计算公式：left=(父元素的宽 - 子元素的宽 ) / 2=(200-100) / 2=50px;子元素（conter）的top值计算公式：top=(父元素的高 - 子元素的高 ) / 2=(200-100) / 2=50px; 方法二计算公式：left值固定为50%;子元素的margin-left= -（子元素的宽/2）=-100/2= -50px;top值也一样，固定为50% 子元素的margin-top= -（子元素的高/2）=-100/2= -50px; 方法七：兼容低版本浏览器，不固定宽高12345678910111213&lt;!-- html --&gt;&lt;div class=\"table\"&gt; &lt;div class=\"tableCell\"&gt; &lt;div class=\"content\"&gt;不固定宽高，自适应&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; /*css*/.table &#123; height: 200px; /*高度值不能少*/ width: 200px; /*宽度值不能少*/ display: table; position: relative; float: left; background: yellow; &#125;.tableCell &#123; display: table-cell; vertical-align: middle; text-align: center; *position: absolute; padding: 10px; *top: 50%; *left: 50%; &#125;.content &#123; *position: relative; *top: -50%; *left: -50%; background: green; &#125; 暂时总结上面的七种，这种方法太多，其实只要习惯了其中的一两种也就够用了。 总结如果是移动端，那么用方法四和方法五是比较方便的。而且支持不固定宽高的情况，快、准、狠 也就是用 flex; align-items: center; justify-content: center; 1234567891011121314151617181920&lt;!-- html --&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /* css */.wrap &#123; background: yellow; width: 200px; height: 200px; display: flex; align-items: center; justify-content: center;&#125; .center &#123; background: green; width: 100px; height: 100px;&#125; 或者display:flex;margin:auto; 12345678910111213141516171819&lt;!-- html --&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /* css */.wrap &#123; background: yellow; width: 200px; height: 200px; display: flex;&#125; .center &#123; background: green; width: 100px; height: 100px; margin: auto;&#125; 如果是PC端，要考虑兼容性的话。方法六是不错滴，也就是纯position。 123456789101112131415161718192021222324252627282930313233&lt;!-- html --&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt;&lt;/div&gt; /* css */.wrap &#123; background: yellow; width: 200px; height: 200px; position: relative;&#125;/**方法一**/.center &#123; background: green; position: absolute; width: 100px; height: 100px; left: 50px; top: 50px; &#125;/**方法二**/.center &#123; background: green; position: absolute; width: 100px; height: 100px; left: 50%; top: 50%; margin-left:-50px; margin-top:-50px;&#125; 如果PC端的中间的元素高度不固定，那么就用方法七即可，代码就不复制了 这种css元素垂直的如果真的要总结起来，应该有十几二十几种。不过也没必要全部掌握吧，只要大概了解一些，用起来没有副作用就行。","categories":[],"tags":[]},{"title":"JS中几种继承模型","slug":"javascript/JS中几种继承模型","date":"2015-02-04T16:00:00.000Z","updated":"2017-03-05T06:49:14.736Z","comments":true,"path":"2015/02/05/javascript/JS中几种继承模型/","link":"","permalink":"http://yoursite.com/2015/02/05/javascript/JS中几种继承模型/","excerpt":"一、 扩展原型对象实现继承123function Person()&#123;&#125; Person.prototype.say=function()&#123;&#125;; var p1=new Person();","text":"一、 扩展原型对象实现继承123function Person()&#123;&#125; Person.prototype.say=function()&#123;&#125;; var p1=new Person(); 二、 替换原型对象实现继承123456Person.prototype=&#123; constructor:Person, run:function()&#123;&#125;&#125;;var p2=new Person();console.log(p1.__proto__===p2.__proto__);//false 三、 替换原型对象实现继承混入(拷贝)继承:$.extend 将其中一个对象的属性和方法拷贝到另外一个对象中1234567var o1=&#123;name:&quot;zhangsan&quot;,age:20&#125;;var o2=&#123;gender:&quot;男&quot;&#125;;for (var key in o1) &#123; //key表示每一次遍历的属性的名称 o2[key]=o1[key];&#125; 混入继承的封装12345678910111213/** * 混入继承 * @param target 接受数据的对象 * @param source 提供数据的对象 * @returns &#123;*&#125; */function extend(target,source)&#123; for (var key in source) &#123; //key表示每一次遍历的属性的名称 target[key]=source[key]; &#125; return target;&#125; 四、 原型混入继承利用混入继承的原理向原型对象中添加属性和方法连接上面的封装1extend(Person.prototype,&#123;jump:function()&#123;&#125;&#125;); 五、原型式继承已知一个对象，需要创建一个新的对象，让新的对象继承自原来的对象特点：在创建对象的时候不需要关心对象的构造函数123456var o3=&#123; age:20 &#125;;function F()&#123;&#125;F.prototype=o3;//让F的实例继承自o3var o4=new F();//o4.__proto__:F.prototype:o3var o5=new F();//o5.__proto__:o3var o6=Object.create(o3); 六、寄生继承123456789101112131415//6.1、寄生继承function create(name)&#123; var obj=Object.create(null); obj.name=name; return obj;&#125;//6.2、寄生构造函数：function Animal(name,color)&#123; var obj=&#123;&#125;; obj.name=name; obj.color=color; return obj;&#125;var cat=new Animal();","categories":[],"tags":[]},{"title":"JS 原型与原型链详解","slug":"javascript/JS 原型与原型链详解","date":"2015-01-13T16:00:00.000Z","updated":"2017-03-05T06:49:10.517Z","comments":true,"path":"2015/01/14/javascript/JS 原型与原型链详解/","link":"","permalink":"http://yoursite.com/2015/01/14/javascript/JS 原型与原型链详解/","excerpt":"一. 普通对象与函数对象 JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是 JS 自带的函数对象。下面举例说明","text":"一. 普通对象与函数对象 JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是 JS 自带的函数对象。下面举例说明 var o1 = {}; var o2 =new Object(); var o3 = new f1(); function f1(){}; var f2 = function(){}; var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;); console.log(typeof Object); //function console.log(typeof Function); //function console.log(typeof f1); //function console.log(typeof f2); //function console.log(typeof f3); //function console.log(typeof o1); //object console.log(typeof o2); //object console.log(typeof o3); //object 在上面的例子中 o1 o2 o3 为普通对象，f1 f2 f3 为函数对象。怎么区分，其实很简单，凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。 一定要分清楚普通对象和函数对象，下面我们会常常用到它。 二. 构造函数 我们先复习一下构造函数的知识： function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function() { alert(this.name) } } var person1 = new Person(&apos;Zaxlct&apos;, 28, &apos;Software Engineer&apos;); var person2 = new Person(&apos;Mick&apos;, 23, &apos;Doctor&apos;); 上面的例子中 person1 和 person2 都是 Person 的实例。这两个实例都有一个 constructor （构造函数）属性，该属性（是一个指针）指向 Person。 即： console.log(person1.constructor == Person); //true console.log(person2.constructor == Person); //true 我们要记住两个概念（构造函数，实例）： person1 和 person2 都是 构造函数 Person 的实例 一个公式： 实例的构造函数属性（constructor）指向构造函数。 三. 原型对象 在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象。（先用不管什么是 proto 第二节的课程会详细的剖析） function Person() {} Person.prototype.name = &apos;Zaxlct&apos;; Person.prototype.age = 28; Person.protetype.job = &apos;Software Engineer&apos;; Person.prototype.sayName = function() { alert(this.name); } var person1 = new Person(); person1.sayName(); // &apos;Zaxlct&apos; var person2 = new Person(); person2.sayName(); // &apos;Zaxlct&apos; console.log(person1.sayname == person2.sayname); //true 我们得到了本文第一个「定律」： 每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性 那什么是原型对象呢？ 我们把上面的例子改一改你就会明白了： Person.prototype = { name: &apos;Zaxlct&apos;, age: 28, job: &apos;Software Engineer&apos;, sayName: function() { alert(this.name); } } 原型对象，顾名思义，它就是一个普通对象（废话 = =!）。从现在开始你要牢牢记住原型对象就是 Person.prototype ，如果你还是害怕它，那就把它想想成一个字母 A： var A = Person.prototype 在上面我们给 A 添加了 四个属性：name、age、job、sayName。其实它还有一个默认的属性：constructor 在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person） 上面这句话有点拗口，我们「翻译」一下：A 有一个默认的 constructor 属性，这个属性是一个指针，指向 Person。即： Person.prototype.constructor == Person 在上面第二小节《构造函数》里，我们知道实例的构造函数属性（constructor）指向构造函数 ：person1.constructor == Person 这两个「公式」好像有点联系： person1.constructor == Person Person.prototype.constructor == Person person1 为什么有 constructor 属性？那是因为 person1 是 Person 的实例。 那 Person.prototype 为什么有 constructor 属性？？同理， Person.prototype （你把它想象成 A） 也是Person 的实例。 也就是在 Person 创建的时候，创建了一个它的实例对象并赋值给它的 prototype，基本过程如下： var A = new Person(); Person.prototype = A; 结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。 原型对象其实就是普通对象（但 Function.prototype 除外，它是函数对象，但它很特殊，他没有prototype属性（前面说道函数对象都有prototype属性））。看下面的例子： function Person(){}; console.log(Person.prototype) //Person{} console.log(typeof Person.prototype) //Object console.log(typeof Function.prototype) // Function，这个特殊 console.log(typeof Object.prototype) // Object console.log(typeof Function.prototype.prototype) //undefined Function.prototype 为什么是函数对象呢？ var A = new Function (); Function.prototype = A; 上文提到凡是通过 new Function( ) 产生的对象都是函数对象。因为 A 是函数对象，所以Function.prototype 是函数对象。 那原型对象是用来做什么的呢？主要作用是用于继承。举个例子： var Person = function(name){ this.name = name; // tip: 当函数执行时这个 this 指的是谁？ }; Person.prototype.getName = function(){ return this.name; // tip: 当函数执行时这个 this 指的是谁？ } var person1 = new person(&apos;Mick&apos;); person1.getName(); //Mick 从这个例子可以看出，通过给 Person.prototype 设置了一个函数对象的属性，那有 Person 的实例（person1）出来的普通对象就继承了这个属性。具体是怎么实现的继承，就要讲到下面的原型链了。 小问题，上面两个 this 都指向谁？ var person1 = new person(&apos;Mick&apos;); person1.name = &apos;Mick&apos;; // 此时 person1 已经有 name 这个属性了 person1.getName(); //Mick 故两次 this 在函数执行时都指向 person1。 四. proto JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做proto 的内置属性，用于指向创建它的构造函数的原型对象。 对象 person1 有一个 proto属性，创建它的构造函数是 Person，构造函数的原型对象是 Person.prototype ，所以： person1.proto == Person.prototype 请看下图： 《JavaScript 高级程序设计》的图 6-1 根据上面这个连接图，我们能得到： Person.prototype.constructor == Person; person1.__proto__ == Person.prototype; person1.constructor == Person; 不过，要明确的真正重要的一点就是，这个连接存在于实例（person1）与构造函数（Person）的原型对象（Person.prototype）之间，而不是存在于实例（person1）与构造函数（Person）之间。 注意：因为绝大部分浏览器都支持proto属性，所以它才被加入了 ES6 里（ES5 部分浏览器也支持，但还不是标准）。 五. 构造器 熟悉 Javascript 的童鞋都知道，我们可以这样创建一个对象： var obj = {} 它等同于下面这样： var obj = new Object() obj 是构造函数（Object）的一个实例。所以： obj.constructor === Object obj.proto === Object.prototype 新对象 obj 是使用 new 操作符后跟一个构造函数来创建的。构造函数（Object）本身就是一个函数（就是上面说的函数对象），它和上面的构造函数 Person 差不多。只不过该函数是出于创建新对象的目的而定义的。所以不要被 Object 吓倒。 同理，可以创建对象的构造器不仅仅有 Object，也可以是 Array，Date，Function等。 所以我们也可以构造函数来创建 Array、 Date、Function var b = new Array(); b.constructor === Array; b.__proto__ === Array.prototype; var c = new Date(); c.constructor === Date; c.__proto__ === Date.prototype; var d = new Function(); d.constructor === Function; d.__proto__ === Function.prototype; 这些构造器都是函数对象： 函数对象 六. 原型链 小测试来检验一下你理解的怎么样： person1.proto 是什么？ Person.proto 是什么？ Person.prototype.proto 是什么？ Object.proto 是什么？ Object.prototypeproto 是什么？ 答案： 第一题： 因为 person1.proto === person1[的构造函数].prototype 因为 person1[的构造函数] === Person 所以 person1.proto === Person.prototype 第二题： 因为 Person.proto === person1[的构造函数].prototype 因为 Person[的构造函数] === Function 所以 Person.proto === Function.prototype 第三题： 因为 Person.prototypeproto === Person.prototype[的构造函数].prototype 因为 Person.prototype[的构造函数] === Object 所以 Person.proto === Object.prototype 第四题，参照第二题，因为 Person 和 Object 一样都是构造函数 第五题： Object.prototype 对象也有proto属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端。 Object.prototype.proto === null 七. 函数对象 （复习一下前面的知识点） 所有函数对象的proto都指向Function.prototype，它是一个空函数（Empty function） Number.__proto__ === Function.prototype // true Number.constructor == Function //true Boolean.__proto__ === Function.prototype // true Boolean.constructor == Function //true String.__proto__ === Function.prototype // true String.constructor == Function //true // 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身 Object.__proto__ === Function.prototype // true Object.constructor == Function // true // 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身 Function.__proto__ === Function.prototype // true Function.constructor == Function //true Array.__proto__ === Function.prototype // true Array.constructor == Function //true RegExp.__proto__ === Function.prototype // true RegExp.constructor == Function //true Error.__proto__ === Function.prototype // true Error.constructor == Function //true Date.__proto__ === Function.prototype // true Date.constructor == Function //true JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的proto是Object.prototype。如下 Math.__proto__ === Object.prototype // true Math.construrctor == Object // true JSON.__proto__ === Object.prototype // true JSON.construrctor == Object //true 上面说的函数对象当然包括自定义的。如下 // 函数声明 function Person() {} // 函数表达式 var Perosn = function() {} console.log(Person.__proto__ === Function.prototype) // true console.log(Man.__proto__ === Function.prototype) // true 这说明什么呢？ 所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind （你应该明白第一句话，第二句话我们下一节继续说，先挖个坑：）） Function.prototype也是唯一一个typeof XXX.prototype为 function的prototype。其它的构造器的prototype都是一个对象（原因第三节里已经解释过了）。如下（又复习了一遍）： console.log(typeof Function.prototype) // function console.log(typeof Object.prototype) // object console.log(typeof Number.prototype) // object console.log(typeof Boolean.prototype) // object console.log(typeof String.prototype) // object console.log(typeof Array.prototype) // object console.log(typeof RegExp.prototype) // object console.log(typeof Error.prototype) // object console.log(typeof Date.prototype) // object console.log(typeof Object.prototype) // object 噢，上面还提到它是一个空的函数，console.log(Function.prototype) 下看看（留意，下一节会再说一下这个） 知道了所有构造器（含内置及自定义）的proto都是Function.prototype，那Function.prototype的proto是谁呢？ 相信都听说过JavaScript中函数也是一等公民，那从哪能体现呢？如下 console.log(Function.prototype.proto === Object.prototype) // true 这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。（你也应该明白第一句话，第二句话我们下一节继续说，不用挖坑了，还是刚才那个坑；）） 最后Object.prototype的proto是谁？ Object.prototype.proto === null // true 已经到顶了，为null。(读到现在，再回过头看第五章，能明白吗？) 八. Prototype 在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 prototype 属性了。对于 ECMAScript 中的引用类型而言，prototype 是保存着它们所有实例方法的真正所在。换句话所说，诸如 toString()和 valuseOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。 ——《JavaScript 高级程序设计》第三版 P116 我们知道 JS 内置了一些方法供我们使用，比如： 对象可以用 constructor/toString()/valueOf() 等方法; 数组可以用 map()/filter()/reducer() 等方法； 数字可用用 parseInt()/parseFloat()等方法； Why ？？？ why?? 当我们创建一个函数时： var Person = new Object() Person 是 Object 的实例，所以 Person 继承了Object 的原型对象Object.prototype上所有的方法： Object.prototype Object 的每个实例都具有以上的属性和方法。 所以我可以用 Person.constructor 也可以用 Person.hasOwnProperty。 当我们创建一个数组时： var num = new Array() num 是 Array 的实例，所以 num 继承了Array 的原型对象Array.prototype上所有的方法： Array.prototype Are you f*ing kidding me? 这尼玛怎么是一个空数组？？？ doge 我们可以用一个 ES5 提供的新方法：Object.getOwnPropertyNames 获取所有（包括不可枚举的属性）的属性名不包括 prototy 中的属性，返回一个数组： var arrayAllKeys = Array.prototype; // [] 空数组 // 只得到 arrayAllKeys 这个对象里所有的属性名(不会去找 arrayAllKeys.prototype 中的属性) console.log(Object.getOwnPropertyNames(arrayAllKeys)); /* 输出： [&quot;length&quot;, &quot;constructor&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;join&quot;, &quot;pop&quot;, &quot;push&quot;, &quot;concat&quot;, &quot;reverse&quot;, &quot;shift&quot;, &quot;unshift&quot;, &quot;slice&quot;, &quot;splice&quot;, &quot;sort&quot;, &quot;filter&quot;, &quot;forEach&quot;, &quot;some&quot;, &quot;every&quot;, &quot;map&quot;, &quot;indexOf&quot;, &quot;lastIndexOf&quot;, &quot;reduce&quot;, &quot;reduceRight&quot;, &quot;entries&quot;, &quot;keys&quot;, &quot;copyWithin&quot;, &quot;find&quot;, &quot;findIndex&quot;, &quot;fill&quot;] */ 这样你就明白了随便声明一个数组，它为啥能用那么多方法了。 细心的你肯定发现了Object.getOwnPropertyNames(arrayAllKeys) 输出的数组里并没有 constructor/hasOwnPrototype等对象的方法（你肯定没发现）。 但是随便定义的数组也能用这些方法 var num = [1]; console.log(num.hasOwnPrototype()) // false (输出布尔值而不是报错) Why ？？？ why?? 因为Array.prototype 虽然没这些方法，但是它有原型对象（proto）： // 上面我们说了 Object.prototype 就是一个普通对象。 Array.prototype.__proto__ == Object.prototype 所以 Array.prototype 继承了对象的所有方法，当你用num.hasOwnPrototype()时，JS 会先查一下它的构造函数 （Array） 的原型对象 Array.prototype 有没有有hasOwnPrototype()方法，没查到的话继续查一下 Array.prototype 的原型对象 Array.prototype.proto有没有这个方法。 当我们创建一个函数时： var f = new Function(&quot;x&quot;,&quot;return x*x;&quot;); //当然你也可以这么创建 f = function(x){ return x*x } console.log(f.arguments) // arguments 方法从哪里来的？ console.log(f.call(window)) // call 方法从哪里来的？ console.log(Function.prototype) // function() {} （一个空的函数） console.log(Object.getOwnPropertyNames(Function.prototype)); /* 输出 [&quot;length&quot;, &quot;name&quot;, &quot;arguments&quot;, &quot;caller&quot;, &quot;constructor&quot;, &quot;bind&quot;, &quot;toString&quot;, &quot;call&quot;, &quot;apply&quot;] */ 我们再复习第八小节这句话： 所有函数对象proto都指向 Function.prototype，它是一个空函数（Empty function） 嗯，我们验证了它就是空函数。不过不要忽略前半句。我们枚举出了它的所有的方法，所以所有的函数对象都能用，比如: 函数对象 如果你还没搞懂啥是函数对象？ 去屎 | center 还有，我建议你可以再复习下为什么： Function.prototype 是唯一一个typeof XXX.prototype为 “function”的prototype 我猜你肯定忘了。 九. 复习一下 第八小节我们总结了： 所有函数对象的 __proto__ 都指向 Function.prototype，它是一个空函数（Empty function） 但是你可别忘了在第三小节我们总结的： 所有对象的 __proto__ 都指向其构造器的 prototype 咦，我找了半天怎么没找到这句话…… doge | center 我们下面再复习下这句话。 先看看 JS 内置构造器： var obj = {name: &apos;jack&apos;} var arr = [1,2,3] var reg = /hello/g var date = new Date var err = new Error(&apos;exception&apos;) console.log(obj.__proto__ === Object.prototype) // true console.log(arr.__proto__ === Array.prototype) // true console.log(reg.__proto__ === RegExp.prototype) // true console.log(date.__proto__ === Date.prototype) // true console.log(err.__proto__ === Error.prototype) // true 再看看自定义的构造器，这里定义了一个 Person： function Person(name) { this.name = name; } var p = new Person(&apos;jack&apos;) console.log(p.__proto__ === Person.prototype) // true p 是 Person 的实例对象，p 的内部原型总是指向其构造器 Person 的原型对象 prototype。 每个对象都有一个 constructor 属性，可以获取它的构造器，因此以下打印结果也是恒等的： function Person(name) { this.name = name } var p = new Person(&apos;jack&apos;) console.log(p.__proto__ === p.constructor.prototype) // true 上面的Person没有给其原型添加属性或方法，这里给其原型添加一个getName方法： function Person(name) { this.name = name } // 修改原型 Person.prototype.getName = function() {} var p = new Person(&apos;jack&apos;) console.log(p.__proto__ === Person.prototype) // true console.log(p.__proto__ === p.constructor.prototype) // true 可以看到p.proto与Person.prototype，p.constructor.prototype都是恒等的，即都指向同一个对象。 如果换一种方式设置原型，结果就有些不同了： function Person(name) { this.name = name } // 重写原型 Person.prototype = { getName: function() {} } var p = new Person(&apos;jack&apos;) console.log(p.__proto__ === Person.prototype) // true console.log(p.__proto__ === p.constructor.prototype) // false 这里直接重写了 Person.prototype（注意：上一个示例是修改原型）。输出结果可以看出p.proto仍然指向的是Person.prototype，而不是p.constructor.prototype。 这也很好理解，给Person.prototype赋值的是一个对象直接量{getName: function(){}}，使用对象直接量方式定义的对象其构造器（constructor）指向的是根构造器Object，Object.prototype是一个空对象{}，{}自然与{getName: function(){}}不等。如下： var p = {} console.log(Object.prototype) // 为一个空的对象{} console.log(p.constructor === Object) // 对象直接量方式定义的对象其constructor为Object console.log(p.constructor.prototype === Object.prototype) // 为true，不解释(๑ˇ3ˇ๑) 十. 原型链（再复习一下：） 下面这个例子你应该能明白了！ function Person(){} var person1 = new Person(); console.log(person1.__proto__ === Person.prototype); // true console.log(Person.prototype.__proto__ === Object.prototype) //true console.log(Object.prototype.__proto__) //null Person.__proto__ == Function.prototype; //true console.log(Function.prototype)// function(){} (空函数) var num = new Array() console.log(num.__proto__ == Array.prototype) // true console.log( Array.prototype.__proto__ == Object.prototype) // true console.log(Array.prototype) // [] (空数组) console.log(Object.prototype.__proto__) //null console.log(Array.__proto__ == Function.prototype)// true 疑点解惑： Object.proto === Function.prototype // trueObject 是函数对象，是通过new Function()创建的，所以Object.proto指向Function.prototype。（参照第八小节：「所有函数对象的proto都指向Function.prototype」） Function.proto === Function.prototype // trueFunction 也是对象函数，也是通过new Function()创建，所以Function.proto指向Function.prototype。自己是由自己创建的，好像不符合逻辑，但仔细想想，现实世界也有些类似，你是怎么来的，你妈生的，你妈怎么来的，你姥姥生的，……类人猿进化来的，那类人猿从哪来，一直追溯下去……，就是无，（NULL生万物）正如《道德经》里所说“无，名天地之始”。 Function.prototype.proto === Object.prototype //true其实这一点我也有点困惑，不过也可以试着解释一下。Function.prototype是个函数对象，理论上他的proto应该指向 Function.prototype，就是他自己，自己指向自己，没有意义。JS一直强调万物皆对象，函数对象也是对象，给他认个祖宗，指向Object.prototype。Object.prototype.proto === null，保证原型链能够正常结束。 十一 总结 原型和原型链是JS实现继承的一种模型。 原型链的形成是真正是靠proto 而非prototype 要深入理解这句话，我们再举个例子，看看前面你真的理解了吗？ var animal = function(){}; var dog = function(){}; animal.price = 2000; dog.prototype = animal; var tidy = new dog(); console.log(dog.price) //undefined console.log(tidy.price) // 2000 这里解释一下： var dog = function(){}; dog.prototype.price = 2000; var tidy = new dog(); console.log(tidy.price); // 2000 console.log(dog.price); //undefined var dog = function(){}; var tidy = new dog(); tidy.price = 2000; console.log(dog.price); //undefined 这个明白吧？想一想我们上面说过这句话： 实例（tidy）和 原型对象（dog.prototype）存在一个连接。不过，要明确的真正重要的一点就是，这个连接存在于实例（tidy）与构造函数的原型对象（dog.prototype）之间，而不是存在于实例（tidy）与构造函数（dog）之间。 聪明的你肯定想通了吧 ：）","categories":[],"tags":[]}]}